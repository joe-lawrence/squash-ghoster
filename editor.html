<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squash Ghoster - Workout Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto+Mono&display=swap" rel="stylesheet">
    
    <!-- Setup WorkoutLib for preview functionality -->
    <script type="module">
        import {
            loadWorkoutFromJsonWithValidation,
            generateWorkoutTimeline,
            timelineEventsToJson,
            timelineEventsToSoundEvents,
            calculateWorkoutStats,
            estimateTTSDuration,
            generatePreviewHtml,
            validateWorkoutJSON,
            validatePatternJSON,
            validateEntryJSON,
            calculateMessageDuration
        } from "./lib/parser.js";

        import {
            parseTimeLimit,
            formatTime,
            formatTimePrecise,
            formatTimeHighPrecision,
            formatRemainingTime
        } from "./lib/timing.js";

        import {
            shuffleArray,
            shuffleArrayRespectingLinks
        } from "./lib/utils.js";

        import { 
            findPatternInsertionPositionShared 
        } from "./lib/clone-utils.js";

        // Create the WorkoutLib API using the new library directly
        window.WorkoutLib = {
            calculateWorkoutStats,
            estimateTTSDuration,
            parseTimeLimit,
            formatTime,
            formatTimePrecise,
            formatTimeHighPrecision,
            formatRemainingTime,
            shuffleArray,
            shuffleArrayRespectingLinks,
            generateWorkoutTimeline,
            timelineEventsToJson,
            timelineEventsToSoundEvents,
            loadWorkoutFromJsonWithValidation,
            validateWorkoutJSON,
            validatePatternJSON,
            validateEntryJSON,
            generatePreviewHtml,
            findPatternInsertionPositionShared,
            calculateMessageDuration
        };
        
        // DEBUG: Verify WorkoutLib is properly loaded
        console.log('DEBUG: WorkoutLib loaded with functions:', {
            timelineEventsToSoundEvents: typeof timelineEventsToSoundEvents,
            generateWorkoutTimeline: typeof generateWorkoutTimeline,
            calculateWorkoutStats: typeof calculateWorkoutStats
        });
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .font-mono {
            font-family: 'Roboto Mono', monospace;
        }
        .collapsible {
            cursor: pointer;
        }
        .toggle-icon {
            display: inline-block;
            width: 1.5em;
            text-align: center;
            transition: transform 0.2s ease-in-out;
        }
        .collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 10;
        }
        /* Autocomplete styles */
        #autocomplete-box {
            position: absolute;
            border: 1px solid #d1d5db;
            background-color: white;
            z-index: 20;
            max-height: 150px;
            overflow-y: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .autocomplete-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
        }
        .autocomplete-item:hover, .autocomplete-item.active {
            background-color: #f3f4f6;
        }
        /* Modal Styles */
        #confirmation-modal {
            background-color: rgba(0, 0, 0, 0.5);
        }
        /* Highlight Styles */
        tr.select-row-highlight td:first-child {
            position: relative;
        }
        tr.select-row-highlight td:first-child::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(135deg, #dc2626, #991b1b);
            box-shadow: 0 0 8px rgba(220, 38, 38, 0.4);
        }
        tr.update-row-highlight td:first-child {
            position: relative;
        }
        tr.update-row-highlight td:first-child::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: linear-gradient(135deg, #16a34a, #15803d);
            box-shadow: 0 0 8px rgba(22, 163, 74, 0.4);
        }
                    .select-cell-highlight {
                position: relative;
                background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05)) !important;
                border: 2px solid rgba(239, 68, 68, 0.6) !important;
                box-shadow: inset 0 0 0 1px rgba(239, 68, 68, 0.2);
            }
            .update-cell-highlight {
                position: relative;
                border-bottom: 3px solid #16a34a !important;
                color: #166534 !important;
                font-weight: bold !important;
            }
        /* Hidden state for green highlights */
        .green-highlights-off .update-row-highlight td:first-child::before {
            display: none !important;
        }
        .green-highlights-off .update-row-highlight {
            /* Remove ribbon effects while preserving layout */
            box-shadow: none !important;
        }
        .green-highlights-off .update-cell-highlight {
            border-bottom: none !important;
            color: inherit !important;
            font-weight: inherit !important;
            background: transparent !important;
        }
        
        /* Saved Elements row selection styling */
        tr.selected-for-saving {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(59, 130, 246, 0.05)) !important;
            border: 2px solid rgba(59, 130, 246, 0.6) !important;
            box-shadow: inset 0 0 0 1px rgba(59, 130, 246, 0.2);
        }
        
        /* Position the first cell normally */
        .workout-table td:first-child {
            position: relative;
            padding-left: 0.75rem;
            overflow: visible;
        }
        
        /* Ensure table container has normal overflow */
        .workout-table {
            overflow: visible;
            margin-left: 0;
            position: relative;
        }
        
        /* Ensure workout display container has normal overflow */
        #workout-display {
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            padding-left: 0;
        }
            
            .update-cell-highlight.focused {
                background: linear-gradient(135deg, rgba(22, 163, 74, 0.3), rgba(22, 163, 74, 0.15)) !important;
                border: 3px solid #16a34a !important;
                box-shadow: 0 0 10px rgba(34, 197, 94, 0.6), inset 0 0 0 1px rgba(22, 163, 74, 0.3);
                color: #15803d !important;
                font-weight: bold !important;
            }
            
            /* Focused row styling - bright red ribbon without glow */
            tr.select-row-highlight.focused td:first-child::before {
                background: linear-gradient(135deg, #ef4444, #dc2626) !important;
                z-index: 10;
            }
            
            /* Add floating ghost overlay to focused ribbon */
            tr.select-row-highlight.focused td:first-child::after {
                content: '';
                position: absolute;
                left: 10px;
                top: 50%;
                transform: translateY(-50%);
                width: 22px;
                height: 22px;
                background-image: url('../images/ghost-white.png');
                background-size: contain;
                background-repeat: no-repeat;
                background-position: center;
                z-index: 11;
                animation: table-ghost-bob 2s ease-in-out infinite, table-ghost-glow 3s ease-in-out infinite;
                filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.8)) drop-shadow(0 0 16px rgba(139, 92, 246, 0.4));
            }
            
            /* Green focused row styling - bright green ribbon */
            tr.update-row-highlight.focused td:first-child::before {
                background: linear-gradient(135deg, #16a34a, #15803d) !important;
                z-index: 10;
            }
            /* Cut mode styles */
            tr.cut-row-highlight {
                border: 3px solid #ea580c !important;
                box-shadow: 0 0 12px rgba(234, 88, 12, 0.6) !important;
                background: linear-gradient(135deg, rgba(234, 88, 12, 0.1), rgba(234, 88, 12, 0.05)) !important;
            }
            /* Use the same selection box styling for copy */
            tr.copy-row-highlight {
                border: 3px solid #ea580c !important;
                box-shadow: 0 0 12px rgba(234, 88, 12, 0.6) !important;
                background: linear-gradient(135deg, rgba(234, 88, 12, 0.1), rgba(234, 88, 12, 0.05)) !important;
            }
            /* Copy hover preview class */
            tr.copy-row-hover {
                border: 2px solid #ea580c !important;
                box-shadow: 0 0 8px rgba(234, 88, 12, 0.4) !important;
            }
            .cut-mode tr:hover {
                border: 2px solid #ea580c !important;
                box-shadow: 0 0 8px rgba(234, 88, 12, 0.4) !important;
                cursor: pointer;
            }
            /* Copy mode hover uses same selection box preview */
            .copy-mode tr:hover {
                border: 2px solid #ea580c !important;
                box-shadow: 0 0 8px rgba(234, 88, 12, 0.4) !important;
                cursor: pointer;
            }
            /* Paste insertion indicator: only bottom border */
            tr.paste-insert-highlight {
                border-bottom: 4px solid #10b981 !important;
            }
            /* Paste hover preview */
            tr.paste-row-hover {
                border-bottom: 4px solid #10b981 !important;
            }
            /* Paste mode hover shows intended insertion after the hovered row */
            .paste-mode tr:hover {
                border-bottom: 4px solid #10b981 !important;
                cursor: pointer;
            }
            /* Add insertion indicator: only bottom border (teal) */
            tr.add-insert-highlight {
                border-bottom: 4px solid #14b8a6 !important;
            }
            /* Add hover preview */
            tr.add-row-hover {
                border-bottom: 4px solid #14b8a6 !important;
            }
            /* Add mode hover shows intended insertion after the hovered row */
            .add-mode tr:hover {
                border-bottom: 4px solid #14b8a6 !important;
                cursor: pointer;
            }
            
            @keyframes table-ghost-bob {
                0%, 100% {
                    transform: translateY(-50%) translateX(0px);
                }
                25% {
                    transform: translateY(-50%) translateY(-2px) translateX(-1px);
                }
                50% {
                    transform: translateY(-50%) translateX(1px);
                }
                75% {
                    transform: translateY(-50%) translateY(-2px) translateX(0px);
                }
            }
            
            @keyframes table-ghost-glow {
                0%, 100% {
                    filter: drop-shadow(0 0 8px rgba(139, 92, 246, 0.8)) drop-shadow(0 0 16px rgba(139, 92, 246, 0.4));
                }
                50% {
                    filter: drop-shadow(0 0 12px rgba(139, 92, 246, 1.0)) drop-shadow(0 0 24px rgba(139, 92, 246, 0.6)) drop-shadow(0 0 32px rgba(139, 92, 246, 0.3));
                }
            }
            

        
        /* Editable cell styles */
        .editable-cell {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .editable-cell:hover {
            background-color: rgba(59, 130, 246, 0.1) !important;
        }
        .editable-cell.editing {
            background-color: rgba(59, 130, 246, 0.2) !important;
            border: 2px solid #3b82f6 !important;
            border-radius: 4px;
        }
        .editable-cell input {
            width: 100%;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: inherit;
            outline: none;
            padding: 0;
            margin: 0;
        }
        .editable-cell input:focus {
            outline: none;
        }
        .editable-cell select {
            cursor: pointer;
        }
        .editable-cell select:focus {
            outline: none;
        }
        /* Move Mode styles */
        tr.move-row-highlight {
            outline: 3px solid #3b82f6;
            outline-offset: -2px;
            background: rgba(59, 130, 246, 0.08);
        }
        #move-mode-toggle.mode-active {
            box-shadow: 0 0 12px rgba(99, 102, 241, 0.6), 0 0 4px rgba(99, 102, 241, 0.4);
        }
        .move-mode-active table { position: relative; }
        .move-mode-active table::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(59, 130, 246, 0.02);
            pointer-events: none;
            z-index: 1;
        }
        /* removed inline move controls */
        
        /* Preview Content Styles */
        #preview-summary h1,
        #preview-summary h2,
        #preview-summary h3,
        #preview-timeline h1,
        #preview-timeline h2,
        #preview-timeline h3 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        #preview-summary ul,
        #preview-timeline ul {
            margin: 0.5rem 0;
            padding-left: 1rem;
        }
        
        #preview-summary li,
        #preview-timeline li {
            margin-bottom: 0.25rem;
        }
        
        #preview-timeline .workout-ribbon {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
        }
        
        #preview-timeline .pattern-ribbon {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
        }
        
        #preview-timeline .timing-badge {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        #preview-timeline .timing-badge:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Responsive preview content */
        @media (max-width: 1024px) {
            #preview-summary h1,
            #preview-summary h2,
            #preview-summary h3 {
                font-size: 0.875rem;
            }
            
            #preview-summary ul {
                font-size: 0.75rem;
            }
        }

        /* Column group separators for editor table */
        .workout-table th:nth-child(3),
        .workout-table td:nth-child(3),
        .workout-table th:nth-child(4),
        .workout-table td:nth-child(4),
        .workout-table th:nth-child(8),
        .workout-table td:nth-child(8),
        .workout-table th:nth-child(12),
        .workout-table td:nth-child(12),
        .workout-table th:nth-child(13),
        .workout-table td:nth-child(13),
        .workout-table th:nth-child(15),
        .workout-table td:nth-child(15),
        .workout-table th:nth-child(19),
        .workout-table td:nth-child(19),
        .workout-table th:nth-child(24),
        .workout-table td:nth-child(24) {
            border-left: 2px solid #d1d5db; /* match header bottom border (gray-300) */
        }

        /* Save mode styles - same as copy mode */
        tr.save-row-highlight {
            border: 3px solid #ea580c !important;
            box-shadow: 0 0 12px rgba(234, 88, 12, 0.6) !important;
            background: linear-gradient(135deg, rgba(234, 88, 12, 0.1), rgba(234, 88, 12, 0.05)) !important;
        }
        
        /* Save hover preview class */
        tr.save-row-hover {
            border: 2px solid #ea580c !important;
            box-shadow: 0 0 8px rgba(234, 88, 12, 0.4) !important;
        }
        
        .save-mode tr:hover {
            border: 2px solid #ea580c !important;
            box-shadow: 0 0 8px rgba(234, 88, 12, 0.4) !important;
            cursor: pointer;
        }
        
        /* Paste mode styles for saved elements - same as regular paste mode */
        tr.saved-paste-insert-highlight {
            border-bottom: 4px solid #10b981 !important;
        }
        
        tr.saved-paste-row-hover {
            border-bottom: 4px solid #10b981 !important;
        }
        
        .saved-paste-mode tr:hover {
            border-bottom: 4px solid #10b981 !important;
            cursor: pointer;
        }

    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8 max-w-full">
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Squash Workout Viewer</h1>
            <p class="mt-2 text-lg text-gray-600">Paste your workout JSON or upload a file to see and edit your workout.</p>
        </header>

        <!-- Main Content Grid -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left Panel: JSON Input and Controls -->
            <div class="lg:col-span-2 space-y-6">
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 resize-y overflow-hidden" id="json-input-container" style="min-height: 500px;">
                    <!-- Input Section -->
                    <div>
                        <label for="json-input" class="block text-sm font-medium text-gray-700 mb-2">Workout JSON Input:</label>
                        <textarea id="json-input" rows="15" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 font-mono text-sm shadow-sm"></textarea>
                    </div>

                    <!-- Action Buttons -->
                    <div class="mt-4 flex flex-col sm:flex-row items-center gap-4">
                        <button id="display-button" class="w-full sm:w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all transform hover:scale-105">
                            Display Workout
                        </button>
                        <button id="save-button" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all transform hover:scale-105">
                            Save File
                        </button>
                        <button id="optimize-button" class="w-full sm:w-auto bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all transform hover:scale-105">
                            Optimize JSON
                        </button>
                        <label for="file-input" class="w-full sm:w-auto cursor-pointer bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all transform hover:scale-105 text-center">
                            Upload File
                            <input type="file" id="file-input" class="hidden" accept=".json,.workout.json">
                        </label>
                    </div>
                </div>

                <!-- Navigation Controls -->
                <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-200">
                    <div class="flex justify-between items-center gap-4">
                        <!-- Move controls aligned left -->
                        <div id="move-controls" class="flex items-center gap-2">
                            <button id="move-up-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg shadow-md" title="Move selected row up" disabled>▲</button>
                            <button id="move-mode-toggle" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-3 rounded-lg shadow-md transition-all transform hover:scale-105 text-center" title="Toggle Move Mode (reorder rows)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor" stroke="currentColor"><path d="M240-400v-480h480v480zm80-80h320v-320H320zm320 240v-80h80v80zm-400 0v-80h80v80zM640-80v-80h80v80zm-200 0v-80h80v80zm-200 0v-80h80v80zm240-560"/></svg></button>
                            <button id="move-down-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-3 rounded-lg shadow-md" title="Move selected row down" disabled>▼</button>
                        </div>

                        <!-- Add/Copy/Paste/Cut controls (center-left) -->
                        <div class="flex items-center gap-2">
                            <button id="add-mode-button" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-3 rounded-lg shadow-md transition-all transform hover:scale-105 text-center" title="Add: create a new entry after a row"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor" stroke="currentColor"><path d="M560-280H120v-400h720v120h-80v-40H200v240h360zm-360-80v-240zm560 200v-120H640v-80h120v-120h80v120h120v80H840v120z"/></svg></button>
                            <button id="copy-mode-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-lg shadow-md transition-all transform hover:scale-105 text-center" title="Copy: select a row to copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor" stroke="currentColor"><path d="M360-240q-33 0-56.5-23.5T280-320v-480q0-33 23.5-56.5T360-880h360q33 0 56.5 23.5T800-800v480q0 33-23.5 56.5T720-240zm0-80h360v-480H360zM200-80q-33 0-56.5-23.5T120-160v-560h80v560h440v80zm160-240v-480z"/></svg></button>
                            <button id="paste-mode-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-3 rounded-lg shadow-md transition-all transform hover:scale-105 text-center" title="Paste: select where to insert the copied row"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor" stroke="currentColor"><path d="M200-120q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h167q11-35 43-57.5t70-22.5q40 0 71.5 22.5T594-840h166q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120zm0-80h560v-560h-80v120H280v-120h-80zm280-560q17 0 28.5-11.5T520-800t-11.5-28.5T480-840t-28.5 11.5T440-800t11.5 28.5T480-760"/></svg></button>
                            <button id="cut-mode-button" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-3 rounded-lg shadow-md transition-all transform hover:scale-105 text-center" title="Cut: select a row to delete"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor" stroke="currentColor"><path d="M560-280H120v-400h720v120h-80v-40H200v240h360zm-360-80v-240zm440 104 84-84-84-84 56-56 84 84 84-84 56 56-83 84 83 84-56 56-84-83-84 83z"/></svg></button>
                        </div>
                        
                        <!-- Green row navigation (right) -->
                        <div class="flex items-center gap-4">
                            <div class="flex items-center gap-2 mr-4">
                                <button id="reset-green-highlights-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105" title="Reset green change tracking (set current as baseline)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="white"><path d="M480-320v-100q0-25 17.5-42.5T540-480h100v60H540v100zm60 240q-25 0-42.5-17.5T480-140v-100h60v100h100v60zm280-240v-100H720v-60h100q25 0 42.5 17.5T880-420v100zM720-80v-60h100v-100h60v100q0 25-17.5 42.5T820-80zm111-480h-83q-26-88-99-144t-169-56q-117 0-198.5 81.5T200-480q0 72 32.5 132t87.5 98v-110h80v240H160v-80h94q-62-50-98-122.5T120-480q0-75 28.5-140.5t77-114 114-77T480-840q129 0 226.5 79.5T831-560"/></svg>
                                </button>
                                <button id="green-nav-up-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105" title="Previous green-highlighted row">
                                    ▲
                                </button>
                                <div id="green-nav-index" class="bg-gray-200 text-gray-700 font-mono text-sm px-3 py-2 rounded-lg min-w-[60px] text-center">
                                    -
                                </div>
                                <button id="green-nav-down-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105" title="Next green-highlighted row">
                                    ▼
                                </button>
                                <button id="toggle-green-highlights-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105" title="Toggle green change highlights (on)"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="white"><path d="M80 0v-160h800V0zm160-320h56l312-311-29-29-28-28-311 312zm-80 80v-170l448-447q11-11 25.5-17t30.5-6 31 6 27 18l55 56q12 11 17.5 26t5.5 31q0 15-5.5 29.5T777-687L330-240zm560-504-56-56zM608-631l-29-29-28-28z"/></svg></button>
                            </div>
                            
                            <!-- Columns toggle -->
                            <div class="relative">
                                <button id="columns-toggle-button" class="bg-gray-800 hover:bg-gray-900 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -960 960 960" fill="currentColor" stroke="currentColor"><path d="M121-280v-400q0-33 23.5-56.5T201-760h559q33 0 56.5 23.5T840-680v400q0 33-23.5 56.5T760-200H201q-33 0-56.5-23.5T121-280m79 0h133v-400H200zm213 0h133v-400H413zm213 0h133v-400H626z"/></svg>
                                </button>
                                <div id="columns-dropdown" class="hidden absolute right-0 mt-2 bg-white rounded-lg shadow-xl z-20 border border-gray-200 p-2 space-y-1">
                                    <!-- Column checkboxes will be inserted here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Workout Table -->
                <div id="workout-display" class="bg-white rounded-xl shadow-lg border border-gray-200 overflow-x-auto resize-y overflow-hidden" style="min-height: 300px;">
                    <!-- The hierarchical table will be rendered here -->
                    <div class="p-6 text-center text-gray-500">
                        <p>Your workout details will appear here.</p>
                    </div>
                </div>

                <!-- Batch Query Section -->
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200">
                    <label for="query-input" class="block text-sm font-medium text-gray-700 mb-2">Batch Query:</label>
                    <div class="relative flex flex-col sm:flex-row items-center gap-4">
                        <div class="relative w-full">
                            <input type="text" id="query-input" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 focus:border-green-500 font-mono text-sm shadow-sm" placeholder="e.g., SELECT WHERE type = 'Shot' AND parent.name = 'Warm-up'" autocomplete="off">
                            <div id="autocomplete-box" class="hidden w-full mt-1"></div>
                        </div>
                        <button id="execute-button" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-all transform hover:scale-105">
                            Execute
                        </button>
                        <!-- Selection (red) navigation moved inline to the right of Execute -->
                        <div class="flex items-center gap-4 mr-4">
                            <span class="text-sm font-medium text-gray-600">Selection:</span>
                            <button id="nav-up-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105" title="Previous red-highlighted row">
                                ▲
                            </button>
                            <div id="nav-index" class="bg-gray-200 text-gray-700 font-mono text-sm px-3 py-2 rounded-lg min-w-[60px] text-center">
                                -
                            </div>
                            <button id="nav-down-button" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all transform hover:scale-105" title="Next red-highlighted row">
                                ▼
                            </button>
                        </div>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">
                        Use <code>SELECT</code>, <code>UPDATE</code>, or <code>DELETE</code> with a compound <code>WHERE</code> clause (AND, OR, NOT, (), parent.).
                    </p>
                </div>

            </div>

            <!-- Right Panel: Summary Box -->
            <div class="space-y-6">
                <!-- Summary Box -->
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 resize-y overflow-hidden" id="summary-container">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-900">Summary</h3>
                        <button id="refresh-preview-btn" class="text-sm text-blue-600 hover:text-blue-800">Refresh</button>
                    </div>
                    
                    <!-- Scrollable Summary Content -->
                    <div class="overflow-y-auto" style="height: calc(100% - 3rem);">
                        <!-- Workout Summary -->
                        <div id="preview-summary">
                            <div class="text-center text-gray-500 py-4">
                                <svg class="w-8 h-8 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                                <p class="text-sm">No workout loaded</p>
                            </div>
                        </div>
                        
                        <!-- Timeline Preview -->
                        <div id="preview-timeline">
                            <div class="text-center text-gray-500 py-4">
                                <svg class="w-8 h-8 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                                <p class="text-sm">Timeline will appear here</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Saved Elements Box -->
                <div class="bg-white p-6 rounded-xl shadow-lg border border-gray-200 resize-y overflow-hidden" id="saved-elements-container">
                    <div class="flex items-center justify-between mb-4">
                        <h3 class="text-lg font-semibold text-gray-900">Saved Elements</h3>
                        <button id="save-element-btn" class="text-sm bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md transition-colors" title="Save: select a row in the table to add to Saved Elements">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                            </svg>
                            Save
                        </button>
                    </div>
                    
                    <!-- Saved Elements List -->
                    <div id="saved-elements-list" class="space-y-2 overflow-y-auto" style="height: calc(100% - 3rem);">
                        <div class="text-center text-gray-500 py-4">
                            <svg class="w-6 h-6 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path>
                            </svg>
                            <p class="text-xs">No saved elements</p>
                        </div>
                    </div>
                    

                </div>
            </div>
        </div>

        <!-- Output Section -->
        <div id="error-message" class="mt-6 hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg" role="alert">
            <strong class="font-bold">Error:</strong>
            <span class="block sm:inline" id="error-text"></span>
        </div>




    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="hidden fixed inset-0 z-30 flex items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <h3 class="text-lg font-bold text-gray-900">Confirm Deletion</h3>
            <p id="modal-message" class="mt-2 text-sm text-gray-600">Are you sure you want to delete these items?</p>
            <div class="mt-6 flex justify-end gap-4">
                <button id="cancel-delete" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-delete" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
            </div>
        </div>
    </div>


    <script>
        // --- DOM Element References ---
        const jsonInput = document.getElementById('json-input');
        const displayButton = document.getElementById('display-button');
        const saveButton = document.getElementById('save-button');
        const optimizeButton = document.getElementById('optimize-button');
        const fileInput = document.getElementById('file-input');

        const queryInput = document.getElementById('query-input');
        const executeButton = document.getElementById('execute-button');
        const autocompleteBox = document.getElementById('autocomplete-box');
        const workoutDisplay = document.getElementById('workout-display');
        const errorMessage = document.getElementById('error-message');
        const errorText = document.getElementById('error-text');
        const confirmationModal = document.getElementById('confirmation-modal');
        const modalMessage = document.getElementById('modal-message');
        const confirmDeleteButton = document.getElementById('confirm-delete');
        const cancelDeleteButton = document.getElementById('cancel-delete');
        const columnsToggleButton = document.getElementById('columns-toggle-button');
        const columnsDropdown = document.getElementById('columns-dropdown');
        const moveControls = document.getElementById('move-controls');
        const moveModeToggle = document.getElementById('move-mode-toggle');
        const moveUpButton = document.getElementById('move-up-button');
        const moveDownButton = document.getElementById('move-down-button');
        const navUpButton = document.getElementById('nav-up-button');
        const navDownButton = document.getElementById('nav-down-button');
        const navIndex = document.getElementById('nav-index');
        const greenNavUpButton = document.getElementById('green-nav-up-button');
        const greenNavDownButton = document.getElementById('green-nav-down-button');
        const greenNavIndex = document.getElementById('green-nav-index');
        const toggleGreenHighlightsButton = document.getElementById('toggle-green-highlights-button');
        const cutModeButton = document.getElementById('cut-mode-button');
        const addModeButton = document.getElementById('add-mode-button');
        const copyModeButton = document.getElementById('copy-mode-button');
        const pasteModeButton = document.getElementById('paste-mode-button');
        
        // Preview elements
        const refreshPreviewBtn = document.getElementById('refresh-preview-btn');
        const previewSummary = document.getElementById('preview-summary');
        const previewTimeline = document.getElementById('preview-timeline');
        
        // Saved Elements elements
        const saveElementBtn = document.getElementById('save-element-btn');
        const savedElementsList = document.getElementById('saved-elements-list');

        let pendingQuery = null;
        let currentWorkoutData = null;
        let originalWorkoutData = null; // Store the original data for diff comparison
        let updatedRows = new Set(); // Track rows that have been updated
        let updatedCells = new Map(); // Track specific cells that have been updated
        let updatedProperties = new Map(); // Track updates by property path and node identifier
        // Cut mode state
        let cutModeActive = false;
        let cutSelectedRowId = null;
        // Copy/Paste/Add state
        let copyModeActive = false;
        let pasteModeActive = false;
        let addModeActive = false;
        let copiedRowData = null;
        
        // Saved Elements state
        let savedElements = [];
        let selectedRowForSaving = null;
        let saveModeActive = false;
        let selectedSavedElement = null;
        
        // Add debugging to track when the data is cleared
        const originalClear = updatedRows.clear;
        updatedRows.clear = function() {
            console.log('updatedRows.clear() called from:', new Error().stack);
            return originalClear.call(this);
        };
        
        const originalMapClear = updatedCells.clear;
        updatedCells.clear = function() {
            console.log('updatedCells.clear() called from:', new Error().stack);
            return originalMapClear.call(this);
        };

        // --- Example JSON Data ---
        const exampleJson = {
          "type": "Workout",
          "name": "My Squash Workout",
          "config": {
            "iterationType": "in-order",
            "limits": { "type": "all-shots", "value": null },
            "voice": "Default",
            "speechRate": 1.0,
            "interval": 5.0,
            "intervalOffsetType": "random",
            "intervalOffset": { "min": -0.5, "max": 0.5 },
            "autoVoiceSplitStep": true,
            "shotAnnouncementLeadTime": 2.5,
            "splitStepSpeed": "auto-scale"
          },
          "patterns": [
            {
              "type": "Pattern", "id": "pattern_001", "name": "Warm-up", "positionType": "normal",
              "config": { "iterationType": "shuffle", "limits": { "type": "shot-limit", "value": 10 }, "interval": 4.5 },
              "entries": [
                { "type": "Shot", "id": "shot_001", "name": "Forehand Drive", "positionType": "1", "config": {"repeatCount": 2, "splitStepSpeed": "fast"} },
                { "type": "Shot", "id": "shot_002", "name": "Backhand Drive", "positionType": "normal", "config": { "interval": 6.0 } },
                { "type": "Message", "id": "msg_001", "name": "Rest Period", "positionType": "linked",
                  "config": {
                    "message": "Take a 30 second break",
                    "interval": "00:30",
                    "intervalType": "additional",
                    "countdown": true,
                    "skipAtEndOfWorkout": false
                  }
                },
                { "type": "Shot", "id": "shot_003", "name": "Volley", "positionType": "last" }
              ]
            }
          ]
        };
        
        // --- Initial Setup ---
        // Friendly names preference for headers and column list
        let useFriendlyNames = true;
        try {
            const storedPref = localStorage.getItem('useFriendlyNames');
            if (storedPref !== null) {
                useFriendlyNames = storedPref === 'true';
            }
        } catch (e) {}
        jsonInput.value = JSON.stringify(filterNodeIds(exampleJson), jsonNumberReplacer, 2);
        
        // Initialize with example data for preview
        currentWorkoutData = exampleJson;
        
        // Initialize preview with example data
        setTimeout(() => generateLivePreview(), 100);

        // --- Resizable Box Size Persistence ---
        function saveBoxSizes() {
            try {
                const sizes = {
                    jsonInput: document.getElementById('json-input-container').style.height,
                    workoutDisplay: document.getElementById('workout-display').style.height,
                    summary: document.getElementById('summary-container').style.height,
                    savedElements: document.getElementById('saved-elements-container').style.height
                };
                localStorage.setItem('boxSizes', JSON.stringify(sizes));
            } catch (e) {
                console.log('Could not save box sizes:', e);
            }
        }

        function restoreBoxSizes() {
            try {
                const storedSizes = localStorage.getItem('boxSizes');
                if (storedSizes) {
                    const sizes = JSON.parse(storedSizes);
                    
                    // Restore JSON input height
                    if (sizes.jsonInput) {
                        document.getElementById('json-input-container').style.height = sizes.jsonInput;
                    }
                    
                    // Restore workout display height
                    if (sizes.workoutDisplay) {
                        document.getElementById('workout-display').style.height = sizes.workoutDisplay;
                    }
                    
                    // Restore summary height
                    if (sizes.summary) {
                        document.getElementById('summary-container').style.height = sizes.summary;
                    }
                    
                    // Restore saved elements height
                    if (sizes.savedElements) {
                        document.getElementById('saved-elements-container').style.height = sizes.savedElements;
                    }
                }
            } catch (e) {
                console.log('Could not restore box sizes:', e);
            }
        }

        // Add resize event listeners to save sizes
        function setupResizeListeners() {
            const resizableBoxes = [
                'json-input-container',
                'workout-display',
                'summary-container',
                'saved-elements-container'
            ];
            
            resizableBoxes.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    // Use ResizeObserver for better performance
                    const resizeObserver = new ResizeObserver(() => {
                        saveBoxSizes();
                    });
                    resizeObserver.observe(element);
                }
            });
        }

        // Restore sizes and setup listeners after DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            restoreBoxSizes();
            setupResizeListeners();
        });

        // --- Event Listeners ---
        displayButton.addEventListener('click', handleDisplay);
        saveButton.addEventListener('click', handleSaveFile);
        optimizeButton.addEventListener('click', handleOptimize);
        // Add/Copy/Cut/Paste (toggle on click)
        if (addModeButton) {
            addModeButton.addEventListener('click', () => {
                if (addModeActive) {
                    exitAddMode();
                } else {
                    enterAddMode();
                }
            });
        }
        copyModeButton.addEventListener('click', () => {
            if (copyModeActive) {
                exitCopyMode();
            } else {
                enterCopyMode();
            }
        });
        pasteModeButton.addEventListener('click', () => {
            if (pasteModeActive) {
                exitPasteMode();
            } else {
                enterPasteMode();
            }
        });
        // Cut mode (toggle on click)
        cutModeButton.addEventListener('click', () => {
            if (cutModeActive) {
                exitCutMode();
            } else {
                enterCutMode();
            }
        });
        fileInput.addEventListener('change', handleFileUpload);

        executeButton.addEventListener('click', handleExecuteQuery);
        queryInput.addEventListener('input', handleQueryInput);
        queryInput.addEventListener('keydown', handleAutocompleteKeydown);
        confirmDeleteButton.addEventListener('click', executeConfirmedDeletion);
        cancelDeleteButton.addEventListener('click', () => confirmationModal.classList.add('hidden'));
        columnsToggleButton.addEventListener('click', () => columnsDropdown.classList.toggle('hidden'));
        navUpButton.addEventListener('click', navigateToPreviousRedRow);
        navDownButton.addEventListener('click', navigateToNextRedRow);
        greenNavUpButton.addEventListener('click', navigateToPreviousGreenCell);
        greenNavDownButton.addEventListener('click', navigateToNextGreenCell);
        if (toggleGreenHighlightsButton) {
            toggleGreenHighlightsButton.addEventListener('click', toggleGreenHighlights);
        }
        
        // Preview functionality
        refreshPreviewBtn.addEventListener('click', generateLivePreview);
        
        // Saved Elements functionality
        saveElementBtn.addEventListener('click', handleSaveElement);
        
        // Add event listener for manual JSON input changes
        jsonInput.addEventListener('input', handleJsonInputChange);
        
        document.addEventListener('click', (e) => {
            if (!queryInput.contains(e.target)) hideAutocomplete();
            if (!columnsToggleButton.contains(e.target) && !columnsDropdown.contains(e.target)) {
                columnsDropdown.classList.add('hidden');
            }
            // Cancel cut mode if clicking outside a table row while active
            if (cutModeActive) {
                const clickedInsideRow = e.target.closest && e.target.closest('tbody tr');
                const clickedCutButton = e.target.closest && e.target.closest('#cut-mode-button');
                const clickedModal = e.target.closest && e.target.closest('#confirmation-modal');
                if (!clickedInsideRow && !clickedCutButton && !clickedModal) {
                    exitCutMode();
                }
            }
            // Cancel add/copy/paste if clicking outside rows and their buttons/modal
            if (addModeActive || copyModeActive || pasteModeActive || saveModeActive) {
                const clickedInsideRow = e.target.closest && e.target.closest('tbody tr');
                const clickedCopyButton = e.target.closest && e.target.closest('#copy-mode-button');
                const clickedPasteButton = e.target.closest && e.target.closest('#paste-mode-button');
                const clickedAddButton = e.target.closest && e.target.closest('#add-mode-button');
                const clickedSaveButton = e.target.closest && e.target.closest('#save-element-btn');
                const clickedPasteElementButton = e.target.closest && e.target.closest('#paste-element-btn');
                const clickedModal = e.target.closest && e.target.closest('#confirmation-modal');
                const clickedDialog = e.target.closest && e.target.closest('.fixed.inset-0.z-50');
                if (!clickedInsideRow && !clickedCopyButton && !clickedPasteButton && !clickedAddButton && !clickedSaveButton && !clickedPasteElementButton && !clickedModal && !clickedDialog) {
                    if (addModeActive) exitAddMode();
                    if (copyModeActive) exitCopyMode();
                    if (pasteModeActive) exitPasteMode();
                    if (saveModeActive) exitSaveMode();

                }
            }
            // Turn off move mode if clicking outside table or the move controls
            if (moveModeActive) {
                const clickedInsideTable = e.target.closest && e.target.closest('#workout-display table');
                const clickedMoveControls = e.target.closest && e.target.closest('#move-controls');
                if (!clickedInsideTable && !clickedMoveControls) {
                    moveModeActive = false;
                    moveSelectedRowId = null;
                    moveSelectionLocked = false;
                    // Keep button text static ('Move')
                    // Remove active styling to match Copy/Cut exit
                    if (moveModeToggle) {
                        moveModeToggle.classList.add('bg-indigo-600');
                        moveModeToggle.classList.remove('bg-indigo-800', 'ring-2', 'ring-offset-2', 'ring-indigo-300');
                        moveModeToggle.setAttribute('aria-pressed', 'false');
                    }
                    const tableEl = workoutDisplay.querySelector('table');
                    if (tableEl) tableEl.classList.remove('move-mode-active');
                    document.querySelectorAll('tr.move-row-highlight').forEach(r => r.classList.remove('move-row-highlight'));
                    updateMoveButtonsState();
                }
            }
        });

        // --- Move Mode Logic ---
        function selectRowForMove(rowId) {
            document.querySelectorAll('tr.move-row-highlight').forEach(r => r.classList.remove('move-row-highlight'));
            moveSelectedRowId = rowId;
            const row = document.getElementById(rowId);
            if (row) {
                row.classList.add('move-row-highlight');
            }
            updateMoveButtonsState();
        }

        function updateMoveButtonsState() {
            if (!moveModeActive || !moveSelectedRowId) {
                if (moveUpButton) moveUpButton.disabled = true;
                if (moveDownButton) moveDownButton.disabled = true;
                return;
            }
            const node = findNodeById(currentWorkoutData, moveSelectedRowId);
            const parent = node ? findParentNode(currentWorkoutData, node) : null;
            const collection = parent ? (Array.isArray(parent.entries) ? parent.entries : Array.isArray(parent.patterns) ? parent.patterns : null) : null;
            if (!collection) { if (moveUpButton) moveUpButton.disabled = true; if (moveDownButton) moveDownButton.disabled = true; return; }
            const idx = collection.findIndex(n => (n && (n.id || n.nodeId)) === moveSelectedRowId);
            if (moveUpButton) moveUpButton.disabled = idx <= 0;
            if (moveDownButton) moveDownButton.disabled = idx === -1 || idx >= collection.length - 1;
        }

        function moveSelected(direction) {
            if (!moveModeActive || !moveSelectedRowId) return;
            const node = findNodeById(currentWorkoutData, moveSelectedRowId);
            const parent = node ? findParentNode(currentWorkoutData, node) : null;
            const collection = parent ? (Array.isArray(parent.entries) ? parent.entries : Array.isArray(parent.patterns) ? parent.patterns : null) : null;
            if (!collection) return;
            const normalizeId = (n) => (n && (n.id || n.nodeId)) || '';
            const idx = collection.findIndex(n => normalizeId(n) === moveSelectedRowId);
            if (idx === -1) return;
            const targetIdx = direction === 'up' ? idx - 1 : idx + 1;
            if (targetIdx < 0 || targetIdx >= collection.length) return;
            const [moved] = collection.splice(idx, 1);
            collection.splice(targetIdx, 0, moved);
            isProgrammaticUpdate = true;
            jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
            renderWorkoutTable(currentWorkoutData);
            setTimeout(() => { isProgrammaticUpdate = false; }, 50);
            // Keep the same row selected and locked after move
            selectRowForMove(normalizeId(moved));
            moveSelectionLocked = true;
        }

        if (moveModeToggle) {
            moveModeToggle.addEventListener('click', () => {
                moveModeActive = !moveModeActive;
                if (!moveModeActive) moveSelectedRowId = null;
                // Match button active style like Copy mode
                if (moveModeActive) {
                    moveModeToggle.classList.remove('bg-indigo-600');
                    moveModeToggle.classList.add('bg-indigo-800', 'ring-2', 'ring-offset-2', 'ring-indigo-300');
                    moveModeToggle.setAttribute('aria-pressed', 'true');
                } else {
                    moveModeToggle.classList.add('bg-indigo-600');
                    moveModeToggle.classList.remove('bg-indigo-800', 'ring-2', 'ring-offset-2', 'ring-indigo-300');
                    moveModeToggle.setAttribute('aria-pressed', 'false');
                }
                const tableEl = workoutDisplay.querySelector('table');
                if (tableEl) tableEl.classList.toggle('move-mode-active', moveModeActive);
                if (!moveModeActive) {
                    document.querySelectorAll('tr.move-row-highlight').forEach(r => r.classList.remove('move-row-highlight'));
                    moveSelectionLocked = false;
                }
                updateMoveButtonsState();
            });
        }

        if (moveUpButton) moveUpButton.addEventListener('click', () => moveSelected('up'));
        if (moveDownButton) moveDownButton.addEventListener('click', () => moveSelected('down'));


        // --- Main Functions ---

        function handleJsonInputChange() {
            console.log('handleJsonInputChange called, isProgrammaticUpdate:', isProgrammaticUpdate);
            // Skip if this is a programmatic update
            if (isProgrammaticUpdate) {
                return;
            }
            
            // Debounce the input to avoid excessive processing
            clearTimeout(jsonInputChangeTimeout);
            jsonInputChangeTimeout = setTimeout(() => {
                const jsonString = jsonInput.value;
                if (!jsonString.trim()) {
                    return; // Don't process empty input
                }
                
                try {
                    const newWorkoutData = JSON.parse(jsonString);
                    
                    // Preserve existing nodeId properties from current data
                    const preservedWorkoutData = preserveNodeIds(newWorkoutData, currentWorkoutData);
                    
                    // Always update the table when JSON changes
                    currentWorkoutData = preservedWorkoutData;
                    renderWorkoutTable(currentWorkoutData);
                    
                    // If we have original data, perform diff comparison
                    if (originalWorkoutData) {
                        console.log('handleJsonInputChange: Performing diff comparison...');
                        
                        // Clear existing tracking data
                        updatedRows.clear();
                        updatedCells.clear();
                        updatedProperties.clear();
                        
                        // Compare current data with original
                        const changes = compareWorkoutData(originalWorkoutData, newWorkoutData);
                        console.log('handleJsonInputChange: Found changes:', changes);
                        
                        // Process each change and mark it for highlighting
                        changes.forEach(change => {
                            console.log(`handleJsonInputChange: Processing change: ${change.path} (original: ${change.original}, current: ${change.current})`);
                            
                            // Find the node that contains this property
                            const node = findNodeByPath(newWorkoutData, change.path);
                            if (node) {
                                const nodeId = node.id || node.nodeId;
                                updatedRows.add(nodeId);
                                
                                // Extract the property name from the path
                                const propertyName = extractPropertyNameForCell(change.path);
                                
                                const cellKey = `${nodeId}-${propertyName}`;
                                updatedCells.set(cellKey, true);
                                
                                // Create property key for tracking
                                const nodeIdentifier = node.id || node.name || node.type;
                                const propertyKey = `${node.type}-${nodeIdentifier}-${change.path}`;
                                updatedProperties.set(propertyKey, true);
                                
                                console.log(`handleJsonInputChange: Marked ${change.path} as changed for node ${nodeId}, propertyName: ${propertyName}, cellKey: ${cellKey}`);
                                console.log(`handleJsonInputChange: Looking for cell with data-property="${propertyName}"`);
                            } else {
                                console.log(`handleJsonInputChange: Could not find node for path: ${change.path}`);
                            }
                        });
                        
                        // Apply green highlights
                        console.log('handleJsonInputChange: Applying green highlights...');
                        updatedRows.forEach(nodeId => {
                            const row = document.getElementById(nodeId);
                            if (row) {
                                row.classList.add('update-row-highlight');
                            }
                        });
                        
                        updatedCells.forEach((value, cellKey) => {
                            const lastHyphenIndex = cellKey.lastIndexOf('-');
                            if (lastHyphenIndex !== -1) {
                                const nodeId = cellKey.substring(0, lastHyphenIndex);
                                const propertyName = cellKey.substring(lastHyphenIndex + 1);
                                
                                const row = document.getElementById(nodeId);
                                if (row) {
                                    const cell = row.querySelector(`[data-property="${propertyName}"]`);
                                    if (cell) {
                                        cell.classList.add('update-cell-highlight');
                                    }
                                }
                            }
                        });
                    }
                    
                    // Clear any error messages
                    hideError();
                    
                    // Auto-refresh preview
                    generateLivePreview();
                    
                } catch (e) {
                    // Invalid JSON - show error but don't update table
                    showError(`Invalid JSON format: ${e.message}`);
                }
            }, 300); // 300ms debounce
        }
        
        let jsonInputChangeTimeout = null;
        let isProgrammaticUpdate = false; // Flag to prevent infinite loops
        
        function handleDisplay() {
            hideError();
            clearHighlights();
            const jsonString = jsonInput.value;
            if (!jsonString.trim()) {
                showError("JSON input is empty.");
                return;
            }
            try {
                const workoutData = JSON.parse(jsonString);
                
                // Store the original data for diff comparison
                originalWorkoutData = JSON.parse(JSON.stringify(workoutData));
                currentWorkoutData = workoutData;
                
                // Clear any existing tracking data
                updatedRows.clear();
                updatedCells.clear();
                updatedProperties.clear();
                
                renderWorkoutTable(workoutData);
                
                // Refresh preview
                generateLivePreview();
            } catch (e) {
                showError(`Invalid JSON format: ${e.message}`);
                workoutDisplay.innerHTML = '<div class="p-6 text-center text-gray-500"><p>Could not parse workout data. Please check the JSON format.</p></div>';
            }
        }

        function handleFileUpload(event) {
            hideError();
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                jsonInput.value = e.target.result;
                handleDisplay();
            };
            reader.onerror = () => showError("Failed to read the uploaded file.");
            reader.readAsText(file);
        }

        function handleSaveFile() {
            hideError();
            const jsonString = jsonInput.value;
            if (!jsonString.trim()) {
                showError("JSON input is empty. Nothing to save.");
                return;
            }
            
            try {
                // Validate JSON format
                const workoutData = JSON.parse(jsonString);
                
                // Create a blob with the JSON data
                const blob = new Blob([JSON.stringify(workoutData, null, 2)], { type: 'application/json' });
                
                // Create a download link
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'workout.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showSuccessMessage("Workout saved successfully!");
            } catch (e) {
                showError(`Invalid JSON format: ${e.message}`);
            }
        }

        function handleOptimize() {
            hideError();
            const jsonString = jsonInput.value;
            if (!jsonString.trim()) {
                showError("JSON input is empty. Nothing to optimize.");
                return;
            }
            
            try {
                // Parse and validate the workout
                const workoutData = JSON.parse(jsonString);
                
                // Optimize the workout by removing redundant inherited values
                const optimizedWorkout = optimizeWorkoutJSON(workoutData);
                
                // Update the JSON input with the optimized version
                jsonInput.value = JSON.stringify(optimizedWorkout, null, 2);
                
                showSuccessMessage("Workout JSON optimized successfully! Redundant inherited values have been removed.");
                
                // Update the display if it was already showing
                if (currentWorkoutData) {
                    currentWorkoutData = optimizedWorkout;
                    renderWorkoutTable(optimizedWorkout);
                    generateLivePreview();
                }
            } catch (e) {
                showError(`Failed to optimize workout: ${e.message}`);
            }
        }

        /**
         * Optimizes workout JSON by removing redundant inherited values
         * Based on inheritance rules from json-spec.md
         */
        function optimizeWorkoutJSON(workout) {
            if (!workout || typeof workout !== 'object') {
                return workout;
            }
            
            // Create a deep copy to avoid modifying the original
            const optimized = JSON.parse(JSON.stringify(workout));
            
            // Get workout-level defaults
            const workoutDefaults = workout.config || {};
            
            // Optimize patterns
            if (optimized.patterns && Array.isArray(optimized.patterns)) {
                optimized.patterns = optimized.patterns.map(pattern => 
                    optimizePattern(pattern, workoutDefaults)
                );
            }
            
            return optimized;
        }

        /**
         * Optimizes a pattern by removing redundant inherited values
         */
        function optimizePattern(pattern, workoutDefaults) {
            if (!pattern || typeof pattern !== 'object') {
                return pattern;
            }
            
            const optimized = { ...pattern };
            
            // Get pattern-level defaults (inherited from workout + pattern overrides)
            const patternDefaults = { ...workoutDefaults, ...(pattern.config || {}) };
            
            // Optimize pattern config by removing values that match workout defaults
            if (optimized.config) {
                optimized.config = optimizeConfig(optimized.config, workoutDefaults);
            }
            
            // Optimize entries (shots and messages)
            if (optimized.entries && Array.isArray(optimized.entries)) {
                optimized.entries = optimized.entries.map(entry => 
                    optimizeEntry(entry, patternDefaults)
                );
            }
            
            return optimized;
        }

        /**
         * Optimizes an entry (shot or message) by removing redundant inherited values
         */
        function optimizeEntry(entry, patternDefaults) {
            if (!entry || typeof entry !== 'object') {
                return entry;
            }
            
            const optimized = { ...entry };
            
            // Optimize entry config by removing values that match pattern defaults
            if (optimized.config) {
                optimized.config = optimizeConfig(optimized.config, patternDefaults);
            }
            
            return optimized;
        }

        /**
         * Optimizes a config object by removing redundant inherited values
         */
        function optimizeConfig(config, parentDefaults) {
            if (!config || typeof config !== 'object') {
                return config;
            }
            
            const optimized = {};
            const inheritableProperties = [
                'voice', 'speechRate', 'interval', 'intervalOffsetType', 
                'intervalOffset', 'autoVoiceSplitStep', 'shotAnnouncementLeadTime', 
                'splitStepSpeed'
            ];
            
            // Only include properties that differ from parent defaults
            for (const [key, value] of Object.entries(config)) {
                if (inheritableProperties.includes(key)) {
                    // Check if this value is the same as the parent default
                    if (JSON.stringify(value) !== JSON.stringify(parentDefaults[key])) {
                        optimized[key] = value;
                    }
                    // If it's the same, omit it (will be inherited)
                } else {
                    // Non-inheritable properties are always included
                    optimized[key] = value;
                }
            }
            
            // Handle special cases for intervalOffset
            if (config.intervalOffset && parentDefaults.intervalOffset) {
                if (JSON.stringify(config.intervalOffset) === JSON.stringify(parentDefaults.intervalOffset)) {
                    delete optimized.intervalOffset;
                }
            }
            
            // Handle special cases for repeatCount (defaults to 1)
            if (config.repeatCount === 1) {
                delete optimized.repeatCount;
            }
            
            // Handle special cases for countdown (defaults to false)
            if (config.countdown === false) {
                delete optimized.countdown;
            }
            
            // Handle special cases for intervalType (defaults to "fixed")
            if (config.intervalType === "fixed") {
                delete optimized.intervalType;
            }
            
            // Handle special cases for skipAtEndOfWorkout (defaults to true)
            if (config.skipAtEndOfWorkout === true) {
                delete optimized.skipAtEndOfWorkout;
            }
            
            // Handle special cases for autoVoiceSplitStep (defaults to true)
            if (config.autoVoiceSplitStep === true) {
                delete optimized.autoVoiceSplitStep;
            }
            
            return optimized;
        }







        function handleExecuteQuery() {
            hideError();
            clearHighlights();
            const queryStr = queryInput.value;
            const jsonString = jsonInput.value;

            if (!queryStr.trim()) {
                showError("Query input is empty.");
                return;
            }
            if (!jsonString.trim()) {
                showError("JSON input is empty. Cannot execute query.");
                return;
            }

            try {
                const query = parseQuery(queryStr);
                if (!query) {
                    showError("Invalid query syntax. Use: SELECT, UPDATE, or DELETE.");
                    return;
                }
                
                let workoutData = JSON.parse(jsonString);
                const matches = findMatches(workoutData, query);

                if (query.action === 'SELECT') {
                    const propertiesToHighlight = getPropertiesFromWhereClause(queryStr);
                    matches.forEach(match => {
                        // Use the actual node ID (like shot_181f31b0) if available, otherwise use nodeId
                        const rowId = match.id || match.nodeId;
                        const row = document.getElementById(rowId);
                        if (row) {
                            row.classList.add('select-row-highlight');
                            expandParents(row);
                            highlightMatchingCells(row, propertiesToHighlight, 'select-cell-highlight');
                        }
                    });
                    // Update red counter immediately after selection highlights are applied
                    const redRowsNow = document.querySelectorAll('tr.select-row-highlight');
                    updateNavIndex(-1, redRowsNow.length);
                } else if (query.action === 'UPDATE') {
                    applyUpdateRecursively(workoutData, query, null, {}, 'row', 0);
                    // Recompute highlight tracking vs original to avoid marking reverted values
                    if (originalWorkoutData) {
                        updatedRows.clear();
                        updatedCells.clear();
                        updatedProperties.clear();
                        const changes = compareWorkoutData(originalWorkoutData, workoutData);
                        changes.forEach(change => {
                            const node = findNodeByPath(workoutData, change.path);
                            if (node) {
                                const nodeId = node.id || node.nodeId;
                                if (nodeId) {
                                    updatedRows.add(nodeId);
                                    const propertyName = extractPropertyNameForCell(change.path);
                                    const cellKey = `${nodeId}-${propertyName}`;
                                    updatedCells.set(cellKey, true);
                                    const nodeIdentifier = node.id || node.name || node.type;
                                    const propertyKey = `${node.type}-${nodeIdentifier}-${change.path}`;
                                    updatedProperties.set(propertyKey, true);
                                }
                            }
                        });
                        // No special forcing for type; diff-only so reverted types are not marked
                    }
                    isProgrammaticUpdate = true;
                    jsonInput.value = JSON.stringify(filterNodeIds(workoutData), jsonNumberReplacer, 2);
                    renderWorkoutTable(workoutData);
                    setTimeout(() => {
                        isProgrammaticUpdate = false;
                    }, 100);
                    // Update green counter after re-render based on tracked highlights
                    const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                    updateGreenNavIndex(-1, greenCellsNow.length);

                } else if (query.action === 'DELETE') {
                    if (matches.length === 0) {
                        showError("No items found matching the WHERE clause.");
                        return;
                    }
                    pendingQuery = query;
                    modalMessage.textContent = `Are you sure you want to delete ${matches.length} item(s)? This action cannot be undone.`;
                    confirmationModal.classList.remove('hidden');
                }

            } catch (e) {
                showError(`An error occurred: ${e.message}`);
            }
        }

        function executeConfirmedDeletion() {
            // If cut mode is active and a row is selected, delete that row
            if (cutModeActive && cutSelectedRowId) {
                try {
                    const workoutData = JSON.parse(jsonInput.value);
                    const node = findNodeById(workoutData, cutSelectedRowId);
                    if (!node) {
                        showError('Could not find node for deletion');
                    } else if (node.type === 'Workout') {
                        showError('Cannot delete the root workout node');
                    } else {
                        const parentNode = findParentNode(workoutData, node);
                        const childrenArray = parentNode?.patterns || parentNode?.entries;
                        if (Array.isArray(childrenArray)) {
                            const idx = childrenArray.indexOf(node);
                            if (idx !== -1) {
                                childrenArray.splice(idx, 1);
                                isProgrammaticUpdate = true;
                                jsonInput.value = JSON.stringify(filterNodeIds(workoutData), jsonNumberReplacer, 2);
                                renderWorkoutTable(workoutData);
                                setTimeout(() => { isProgrammaticUpdate = false; }, 100);
                                showSuccessMessage('Row deleted');
                            } else {
                                showError('Selected node not found in parent');
                            }
                        } else {
                            showError('Parent node does not have a children array');
                        }
                    }
                } catch (e) {
                    showError(`Deletion failed: ${e.message}`);
                } finally {
                    exitCutMode();
                    cutSelectedRowId = null;
                    confirmationModal.classList.add('hidden');
                }
                return;
            }
            
            if (!pendingQuery) {
                confirmationModal.classList.add('hidden');
                return;
            }
            
            let workoutData = JSON.parse(jsonInput.value);
            applyDeleteRecursively(workoutData, pendingQuery);

            isProgrammaticUpdate = true;
            jsonInput.value = JSON.stringify(filterNodeIds(workoutData), jsonNumberReplacer, 2);
            renderWorkoutTable(workoutData);
            setTimeout(() => {
                isProgrammaticUpdate = false;
            }, 100);

            pendingQuery = null;
            confirmationModal.classList.add('hidden');
        }
        
        // --- Query Parsing and Evaluation ---

        function buildWhereClauseEvaluator(whereStr) {
            const nodeProps = ['id', 'name', 'type', 'positionType'];
            
            let jsStr = whereStr.replace(/\bAND\b/gi, '&&')
                                .replace(/\bOR\b/gi, '||')
                                .replace(/\bNOT\b/gi, '!');

            const comparisonRegex = /(\b(?:parent\.)?[a-zA-Z_]\w*\b)\s*([<>=!]+)\s*(['"].*?['"]|[0-9.-]+|true|false)/g;
            
            let lastIndex = 0;
            const replacedParts = [];
            
            let match;
            while ((match = comparisonRegex.exec(jsStr)) !== null) {
                const [fullMatch, prop, op, val] = match;
                const offset = match.index;
                
                replacedParts.push(jsStr.substring(lastIndex, offset));

                let jsProp;
                if (prop.startsWith('parent.')) {
                    const parentProp = prop.substring(7);
                    // Handle special cases for parent properties
                    if (parentProp === 'intervalOffsetMin') {
                        jsProp = 'parentEffectiveConfig.intervalOffset?.min';
                    } else if (parentProp === 'intervalOffsetMax') {
                        jsProp = 'parentEffectiveConfig.intervalOffset?.max';
                    } else if (parentProp === 'limits.type') {
                        jsProp = 'parentEffectiveConfig.limits?.type';
                    } else if (parentProp === 'limits.value') {
                        jsProp = 'parentEffectiveConfig.limits?.value';
                    } else {
                        jsProp = nodeProps.includes(parentProp) ? `parentNode.${parentProp}` : `parentEffectiveConfig.${parentProp}`;
                    }
                } else {
                    // Handle special cases for interval offset min/max and limits
                    if (prop === 'intervalOffsetMin') {
                        jsProp = 'effectiveConfig.intervalOffset?.min';
                    } else if (prop === 'intervalOffsetMax') {
                        jsProp = 'effectiveConfig.intervalOffset?.max';
                    } else if (prop === 'limits.type') {
                        jsProp = 'effectiveConfig.limits?.type';
                    } else if (prop === 'limits.value') {
                        jsProp = 'effectiveConfig.limits?.value';
                    } else {
                        jsProp = nodeProps.includes(prop) ? `node.${prop}` : `effectiveConfig.${prop}`;
                    }
                }

                const jsOp = op.replace('=', '==');

                let condition;
                if (val.startsWith("'") || val.startsWith('"')) {
                    condition = `String(${jsProp} ?? '') ${jsOp} ${val}`;
                } else {
                    condition = `${jsProp} ${jsOp} ${val}`;
                }
                replacedParts.push(condition);
                lastIndex = offset + fullMatch.length;
            }
            replacedParts.push(jsStr.substring(lastIndex));

            const finalJsStr = replacedParts.join('');

            try {
                return new Function('node', 'effectiveConfig', 'parentNode', 'parentEffectiveConfig', `return ${finalJsStr};`);
            } catch (e) {
                console.error("Error creating evaluator function:", e, "Generated JS:", finalJsStr);
                showError("Invalid WHERE clause syntax.");
                return null;
            }
        }

        function parseQuery(queryStr) {
            const updateRegex = /^UPDATE\s+([\w\.]+)\s*=\s*(.*?)\s+WHERE\s+(.*)$/i;
            const selectOrDeleteRegex = /^(SELECT|DELETE)\s+WHERE\s+(.*)$/i;

            let match = queryStr.match(updateRegex);
            if (match) {
                const evaluator = buildWhereClauseEvaluator(match[3]);
                if (!evaluator) return null;
                return {
                    action: 'UPDATE',
                    update: { property: match[1], value: match[2].trim() },
                    where: { evaluator }
                };
            }

            match = queryStr.match(selectOrDeleteRegex);
            if (match) {
                const evaluator = buildWhereClauseEvaluator(match[2]);
                if (!evaluator) return null;
                return {
                    action: match[1].toUpperCase(),
                    where: { evaluator }
                };
            }

            return null;
        }

        function checkNode(node, effectiveConfig, query, parentNode, parentEffectiveConfig) {
            try {
                return query.where.evaluator(node, effectiveConfig, parentNode, parentEffectiveConfig);
            } catch (e) {
                return false;
            }
        }

        function findMatches(node, query, parentNode = null, parentEffectiveConfig = {}, idPrefix = 'row', index = 0, matches = []) {
            if (!node || typeof node !== 'object') return matches;

            const effectiveConfig = calculateEffectiveConfigForNode(node, parentEffectiveConfig);
            node.nodeId = `${idPrefix}-${index}`;

            if (checkNode(node, effectiveConfig, query, parentNode, parentEffectiveConfig)) {
                matches.push(node);
            }

            const children = node.patterns || node.entries;
            if (Array.isArray(children)) {
                children.forEach((child, childIndex) => {
                    findMatches(child, query, node, effectiveConfig, node.nodeId, childIndex, matches);
                });
            }
            return matches;
        }

        function applyUpdateRecursively(node, query, parentNode = null, parentEffectiveConfig = {}, idPrefix = 'row', index = 0) {
            if (!node || typeof node !== 'object') return;
            const effectiveConfig = { ...parentEffectiveConfig, ...(node.config || {}) };
            node.nodeId = `${idPrefix}-${index}`;

            if (checkNode(node, effectiveConfig, query, parentNode, parentEffectiveConfig)) {
                // Convert property name to lowercase and handle config properties
                let propertyPath = query.update.property.toLowerCase();
                if (['interval', 'speechrate', 'autovoicesplitstep', 'shotannouncementleadtime', 
                     'splitstepspeed', 'iterationtype', 'intervaltype', 'countdown', 'skipatendofworkout',
                     'intervaloffsettype', 'intervaloffsetmin', 'intervaloffsetmax', 'limits', 'voice'].includes(propertyPath)) {
                    // Handle config properties
                    if (!node.config) node.config = {};
                    
                    // Convert value based on property type
                    let updateValue = query.update.value;
                    const rawTrim = (typeof updateValue === 'string') ? updateValue.trim() : updateValue;
                    // Try JSON parse for object-style values
                    if (typeof rawTrim === 'string' && (rawTrim.startsWith('{') || rawTrim.startsWith('['))) {
                        try { updateValue = JSON.parse(rawTrim); } catch (_) { /* keep as string */ }
                    }
                    if (propertyPath === 'interval' || propertyPath === 'speechrate' || 
                        propertyPath === 'shotannouncementleadtime' || propertyPath === 'repeatcount' ||
                        propertyPath === 'intervaloffsetmin' || propertyPath === 'intervaloffsetmax') {
                        // For Message.interval, keep MM:SS string per spec
                        if (!(node.type === 'Message' && propertyPath === 'interval')) {
                            if (typeof updateValue !== 'object') {
                                updateValue = parseFloat(updateValue);
                                if (isNaN(updateValue)) {
                                    console.error(`Invalid number: ${query.update.value}`);
                                    return;
                                }
                            }
                        }
                    } else if (propertyPath === 'autovoicesplitstep' || propertyPath === 'countdown' || 
                               propertyPath === 'skipatendofworkout') {
                        updateValue = updateValue.toLowerCase() === 'true';
                    }
                    
                    // Handle interval offset min/max separately
                    if (propertyPath === 'intervaloffsetmin' || propertyPath === 'intervaloffsetmax') {
                        if (!node.config.intervalOffset) node.config.intervalOffset = {};
                        if (propertyPath === 'intervaloffsetmin') {
                            node.config.intervalOffset.min = updateValue;
                            // If switching to fixed type, ensure max equals min
                            if (node.config.intervalOffsetType === 'fixed') {
                                node.config.intervalOffset.max = updateValue;
                            }
                        } else {
                            node.config.intervalOffset.max = updateValue;
                            // If switching to fixed type, ensure min equals max
                            if (node.config.intervalOffsetType === 'fixed') {
                                node.config.intervalOffset.min = updateValue;
                            }
                        }
                    } else if (propertyPath.includes('.')) {
                        // Support dotted config paths like limits.type, limits.value
                        const parts = propertyPath.split('.');
                        let target = node.config;
                        for (let i = 0; i < parts.length - 1; i++) {
                            const key = parts[i];
                            if (!target[key] || typeof target[key] !== 'object') target[key] = {};
                            target = target[key];
                        }
                        const lastKey = parts[parts.length - 1];
                        // For limits.value, keep string (MM:SS) when provided
                        target[lastKey] = updateValue;
                        
                        // Track highlights
                        updatedRows.add(node.id || node.nodeId);
                        const cellKey = `${node.id || node.nodeId}-${propertyPath}`;
                        updatedCells.set(cellKey, true);
                        const nodeIdentifier = node.id || node.name || node.type;
                        const propertyKey = `${node.type}-${nodeIdentifier}-config.${propertyPath}`;
                        updatedProperties.set(propertyKey, true);
                        
                        // Done for dotted path
                        
                    } else {
                        node.config[propertyPath] = updateValue;
                    }
                    
                    // Track the updated row and cell for green highlighting
                    updatedRows.add(node.id || node.nodeId);
                    const cellKey = `${node.id || node.nodeId}-${propertyPath}`;
                    updatedCells.set(cellKey, true);
                    
                    // Also track by property path and node identifier for diff system
                    const nodeIdentifier = node.id || node.name || node.type;
                    const propertyKey = `${node.type}-${nodeIdentifier}-config.${propertyPath}`;
                    updatedProperties.set(propertyKey, true);
                    
                    // Special handling for interval offset min/max to ensure both are tracked
                    if (propertyPath === 'intervaloffsetmin' || propertyPath === 'intervaloffsetmax') {
                        const otherPropertyPath = propertyPath === 'intervaloffsetmin' ? 'intervaloffsetmax' : 'intervaloffsetmin';
                        const otherCellKey = `${node.id || node.nodeId}-${otherPropertyPath}`;
                        updatedCells.set(otherCellKey, true);
                        
                        const otherPropertyKey = `${node.type}-${nodeIdentifier}-config.${otherPropertyPath}`;
                        updatedProperties.set(otherPropertyKey, true);
                    }
                } else {
                    // Handle non-config properties
                    let updateValue = query.update.value;
                    if (updateValue === 'true') updateValue = true;
                    else if (updateValue === 'false') updateValue = false;
                    else if (!isNaN(updateValue) && !isNaN(parseFloat(updateValue))) {
                        updateValue = parseFloat(updateValue);
                    }
                    node[propertyPath] = updateValue;
                    
                    // Track the updated row and cell for green highlighting
                    updatedRows.add(node.id || node.nodeId);
                    const cellKey = `${node.id || node.nodeId}-${propertyPath}`;
                    updatedCells.set(cellKey, true);
                    
                    // Also track by property path and node identifier for diff system
                    const nodeIdentifier = node.id || node.name || node.type;
                    const propertyKey = `${node.type}-${nodeIdentifier}-${propertyPath}`;
                    updatedProperties.set(propertyKey, true);
                }
            }

            const children = node.patterns || node.entries;
            if (Array.isArray(children)) {
                children.forEach((child, childIndex) => {
                    applyUpdateRecursively(child, query, node, effectiveConfig, node.nodeId, childIndex);
                });
            }
        }
        
        function applyDeleteRecursively(node, query, parentNode = null, parentEffectiveConfig = {}) {
            if (!node || typeof node !== 'object') return;
            const effectiveConfig = { ...parentEffectiveConfig, ...(node.config || {}) };

            const childrenKey = node.patterns ? 'patterns' : (node.entries ? 'entries' : null);
            if (childrenKey) {
                node[childrenKey] = node[childrenKey].filter(child => {
                    const childEffectiveConfig = { ...effectiveConfig, ...(child.config || {}) };
                    return !checkNode(child, childEffectiveConfig, query, node, effectiveConfig);
                });
                node[childrenKey].forEach(child => applyDeleteRecursively(child, query, node, effectiveConfig));
            }
        }


        // --- Autocomplete Logic ---
        function handleQueryInput(e) {
            const query = e.target.value;
            const workoutData = JSON.parse(jsonInput.value);
            let suggestions = [];

            const cleanQuery = query.toUpperCase();
            
            if (cleanQuery.length > 0 && !cleanQuery.includes(' ')) {
                 suggestions = ['SELECT', 'UPDATE', 'DELETE'].filter(k => k.startsWith(cleanQuery));
            } else if (cleanQuery.endsWith('WHERE ')) {
                // Provide suggestions for all queryable properties
                suggestions = getAllQueryableProperties();
            } else if (cleanQuery.match(/=\s*$/)) {
                const parts = query.split(' ');
                const field = parts[parts.length - 2];
                suggestions = getSuggestions(workoutData, 'nodeValues', field).map(v => typeof v === 'string' ? `'${v}'` : v);
            }

            if (suggestions.length > 0) {
                showAutocomplete(suggestions);
            } else {
                hideAutocomplete();
            }
        }

        function getAllQueryableProperties() {
            // Return all properties that can be used in WHERE clauses
            return [
                // Direct node properties
                'id', 'name', 'type', 'positionType',
                
                // Config properties (these are accessed via effectiveConfig)
                'interval', 'iterationType', 'splitStepSpeed', 
                'shotAnnouncementLeadTime', 'voice', 'speechRate', 'intervalOffsetType',
                'intervalOffsetMin', 'intervalOffsetMax', 'intervalType', 'autoVoiceSplitStep',
                'countdown', 'skipAtEndOfWorkout', 'message',
                // repeatCount subfields
                'repeatCount.type', 'repeatCount.count', 'repeatCount.min', 'repeatCount.max',
                
                // Limits properties (these are accessed via effectiveConfig.limits)
                'limits.type', 'limits.value',
                
                // Parent properties (for parent. queries)
                'parent.id', 'parent.name', 'parent.type', 'parent.positionType',
                'parent.interval', 'parent.iterationType',
                'parent.splitStepSpeed', 'parent.shotAnnouncementLeadTime', 'parent.voice',
                'parent.speechRate', 'parent.intervalOffsetType', 'parent.intervalOffsetMin',
                'parent.intervalOffsetMax', 'parent.intervalType', 'parent.autoVoiceSplitStep',
                'parent.countdown', 'parent.skipAtEndOfWorkout',
                'parent.limits.type', 'parent.limits.value', 'parent.message',
                'parent.repeatCount.type', 'parent.repeatCount.count', 'parent.repeatCount.min', 'parent.repeatCount.max'
            ].sort();
        }

        function getSuggestions(node, type, field = null) {
            let suggestions = new Set();
            const allConfigKeys = [
                'voice', 'speechRate', 'interval', 'intervalOffsetType', 'intervalOffsetMin', 'intervalOffsetMax',
                'autoVoiceSplitStep', 'shotAnnouncementLeadTime', 'splitStepSpeed',
                'iterationType', 'limits', 'repeatCount', 'intervalType',
                'countdown', 'skipAtEndOfWorkout', 'message'
            ];

            if (type === 'configKeys') {
                allConfigKeys.forEach(key => suggestions.add(key));
            } else if (type === 'nodeKeys') {
                Object.keys(node).forEach(key => {
                    if (key !== 'patterns' && key !== 'entries' && key !== 'config') {
                        suggestions.add(key);
                    }
                });
            } else if (type === 'nodeValues' && field) {
                // Collect values using effective config to honor inheritance and nested fields
                const collectValues = (n) => {
                    const effective = calculateEffectiveConfigForNode(n, {});
                    // Direct node property
                    if (n.hasOwnProperty(field)) {
                        suggestions.add(n[field]);
                    }
                    // Config-based properties
                    if (field === 'interval') {
                        suggestions.add(n.type === 'Message' ? (n.config?.interval) : effective.interval);
                    } else if (field === 'intervalOffsetMin') {
                        if (effective.intervalOffset && effective.intervalOffset.min !== undefined) suggestions.add(effective.intervalOffset.min);
                    } else if (field === 'intervalOffsetMax') {
                        if (effective.intervalOffset && effective.intervalOffset.max !== undefined) suggestions.add(effective.intervalOffset.max);
                    } else if (field === 'limits.type') {
                        if (effective.limits && effective.limits.type !== undefined) suggestions.add(effective.limits.type);
                    } else if (field === 'limits.value') {
                        if (effective.limits && effective.limits.value !== undefined) suggestions.add(effective.limits.value);
                    } else if (field === 'message') {
                        if (effective.message !== undefined) suggestions.add(effective.message);
                    } else if (effective.hasOwnProperty(field)) {
                        suggestions.add(effective[field]);
                    }
                };
                collectValues(node);
            }

            const children = node.patterns || node.entries;
            if (Array.isArray(children)) {
                children.forEach(child => {
                    getSuggestions(child, type, field).forEach(s => suggestions.add(s));
                });
            }
            return Array.from(suggestions).sort();
        }
        
        function showAutocomplete(suggestions) {
            autocompleteBox.innerHTML = '';
            if (suggestions.length === 0) {
                hideAutocomplete();
                return;
            }
            suggestions.forEach((suggestion) => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = suggestion;
                item.addEventListener('click', () => {
                    const currentQuery = queryInput.value;
                    
                    let lastSeparatorIndex = -1;
                    for (let i = currentQuery.length - 1; i >= 0; i--) {
                        if (' =<>()!'.includes(currentQuery[i])) {
                            lastSeparatorIndex = i;
                            break;
                        }
                    }

                    const baseQuery = currentQuery.substring(0, lastSeparatorIndex + 1);
                    
                    queryInput.value = baseQuery + suggestion + ' ';
                    queryInput.focus();
                    hideAutocomplete();
                });
                autocompleteBox.appendChild(item);
            });
            autocompleteBox.classList.remove('hidden');
        }

        function hideAutocomplete() {
            autocompleteBox.classList.add('hidden');
        }

        function handleAutocompleteKeydown(e) {
            const items = autocompleteBox.querySelectorAll('.autocomplete-item');
            if (e.key === 'Enter') {
                e.preventDefault();
                const activeItem = autocompleteBox.querySelector('.autocomplete-item.active');
                if (activeItem) {
                    activeItem.click();
                } else {
                    handleExecuteQuery();
                }
                return;
            }

            if (items.length === 0 || autocompleteBox.classList.contains('hidden')) return;

            let activeIndex = -1;
            items.forEach((item, index) => {
                if (item.classList.contains('active')) activeIndex = index;
            });

            if (e.key === 'ArrowDown') {
                e.preventDefault();
                items[activeIndex]?.classList.remove('active');
                activeIndex = (activeIndex + 1) % items.length;
                items[activeIndex].classList.add('active');
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                items[activeIndex]?.classList.remove('active');
                activeIndex = (activeIndex - 1 + items.length) % items.length;
                items[activeIndex].classList.add('active');
            } else if (e.key === 'Escape') {
                hideAutocomplete();
            }
        }


        // --- Rendering Logic ---
        const headers = [
            { key: 'name', name: 'Name' },
            { key: 'type', name: 'Type' },
            { key: 'positionType', name: 'Position Type' },
            { key: 'interval', name: 'Interval' },
            { key: 'intervalOffsetType', name: 'Offset Type' },
            { key: 'intervalOffsetMin', name: 'Offset Min' },
            { key: 'intervalOffsetMax', name: 'Offset Max' },
            { key: 'repeatCount.type', name: 'Repeat Type' },
            { key: 'repeatCount.count', name: 'Repeat Count' },
            { key: 'repeatCount.min', name: 'Repeat Min' },
            { key: 'repeatCount.max', name: 'Repeat Max' },
            { key: 'iterationType', name: 'Iteration Type' },
            { key: 'limits.type', name: 'Limit Type' },
            { key: 'limits.value', name: 'Limit Value' },
            { key: 'message', name: 'Message' },
            { key: 'intervalType', name: 'Message Interval Type' },
            { key: 'countdown', name: 'Countdown' },
            { key: 'skipAtEndOfWorkout', name: 'Skip at End' },
            { key: 'shotAnnouncementLeadTime', name: 'Announcement Lead Time' },
            { key: 'autoVoiceSplitStep', name: 'Auto Voice Split Step' },
            { key: 'speechRate', name: 'Speech Rate' },
            { key: 'splitStepSpeed', name: 'Split Step Speed' },
            { key: 'voice', name: 'Voice' },
            { key: 'id', name: 'Identifier' }
        ];
        const propToColumnIndex = {};
        headers.forEach((h, i) => {
            if (!propToColumnIndex[h.key]) {
                propToColumnIndex[h.key] = [];
            }
            propToColumnIndex[h.key].push(i);
        });

        function getPropertiesFromWhereClause(whereStr) {
            const propRegex = /\b(parent\.)?([a-zA-Z_]\w*)\b/g;
            const properties = new Set();
            const keywords = ['AND', 'OR', 'NOT', 'SELECT', 'UPDATE', 'DELETE', 'WHERE', 'true', 'false', 'null'];
            let match;
            while ((match = propRegex.exec(whereStr)) !== null) {
                if (!keywords.includes(match[0].toUpperCase())) {
                    properties.add(match[0]);
                }
            }
            return Array.from(properties);
        }

        function highlightMatchingCells(row, properties, highlightClass) {
            properties.forEach(prop => {
                const isParentProp = prop.startsWith('parent.');
                const cleanProp = prop.replace('parent.', '');
                const colIndices = propToColumnIndex[cleanProp];

                if (colIndices) {
                    let targetRow = row;
                    if (isParentProp) {
                        const parts = row.id.split('-');
                        if (parts.length > 2) {
                            const parentId = parts.slice(0, -1).join('-');
                            targetRow = document.getElementById(parentId);
                        } else {
                            targetRow = null; 
                        }
                    }

                    if (targetRow) {
                        colIndices.forEach(colIndex => {
                            const cell = targetRow.querySelector(`td:nth-child(${colIndex + 1})`);
                            if (cell) {
                                cell.classList.add(highlightClass);
                            }
                        });
                    }
                }
            });
        }

        function clearHighlights() {
            document.querySelectorAll('.select-row-highlight, .select-cell-highlight').forEach(el => {
                el.classList.remove('select-row-highlight', 'select-cell-highlight');
            });
            // Don't clear update highlights - they should be sticky
        }
        
        function clearUpdateHighlights() {
            console.log('clearUpdateHighlights called - clearing tracking data');
            document.querySelectorAll('.update-row-highlight, .update-cell-highlight').forEach(el => {
                el.classList.remove('update-row-highlight', 'update-cell-highlight');
            });
            // Clear the tracking data
            updatedRows.clear();
            updatedCells.clear();
        }

        let greenHighlightsEnabled = true;
        function toggleGreenHighlights() {
            greenHighlightsEnabled = !greenHighlightsEnabled;
            const root = document.body;
            root.classList.toggle('green-highlights-off', !greenHighlightsEnabled);
            if (toggleGreenHighlightsButton) {
                if (greenHighlightsEnabled) {
                    // Enabled: brighter bg and ring glow ON
                    toggleGreenHighlightsButton.classList.add('bg-green-600', 'ring-2', 'ring-offset-2', 'ring-green-300');
                    toggleGreenHighlightsButton.classList.remove('bg-green-800');
                    toggleGreenHighlightsButton.title = 'Toggle green change highlights (on)';
                } else {
                    // Disabled: darker bg and ring glow OFF
                    toggleGreenHighlightsButton.classList.remove('ring-2', 'ring-offset-2', 'ring-green-300', 'bg-green-600');
                    toggleGreenHighlightsButton.classList.add('bg-green-800');
                    toggleGreenHighlightsButton.title = 'Toggle green change highlights (off)';
                }
            }
        }

        // Hook up reset button
        const resetGreenHighlightsButton = document.getElementById('reset-green-highlights-button');
        if (resetGreenHighlightsButton) {
            resetGreenHighlightsButton.addEventListener('click', resetGreenChangeTracking);
        }

        // Reset current changes as the new baseline for green change tracking
        function resetGreenChangeTracking() {
            // Ask for confirmation using the existing modal
            pendingQuery = null; // Ensure delete flow isn't triggered
            modalMessage.textContent = 'Reset change tracking? This will set the current workout as the new baseline and clear green highlights.';
            // Temporarily repurpose confirm button action
            const previousHandler = executeConfirmedDeletion;
            const cleanup = () => {
                confirmDeleteButton.removeEventListener('click', onConfirmReset);
                cancelDeleteButton.removeEventListener('click', onCancelReset);
                confirmationModal.classList.add('hidden');
            };
            function onConfirmReset() {
                try {
                    clearUpdateHighlights();
                    const currentFiltered = filterNodeIds(currentWorkoutData);
                    originalWorkoutData = JSON.parse(JSON.stringify(currentFiltered));
                    updatedProperties.clear();
                    isProgrammaticUpdate = true;
                    jsonInput.value = JSON.stringify(currentFiltered, jsonNumberReplacer, 2);
                    renderWorkoutTable(currentWorkoutData);
                    setTimeout(() => { isProgrammaticUpdate = false; }, 100);
                    showSuccessMessage('Green change tracking reset. Current state is now the baseline.');
                } catch (e) {
                    console.error('Failed to reset change tracking:', e);
                    showError('Failed to reset change tracking');
                } finally {
                    cleanup();
                }
            }
            function onCancelReset() {
                cleanup();
            }
            confirmDeleteButton.addEventListener('click', onConfirmReset);
            cancelDeleteButton.addEventListener('click', onCancelReset);
            confirmationModal.classList.remove('hidden');
        }

        function expandParents(element) {
            const parts = element.id.split('-');
            if (parts.length <= 2) return; 

            const parentId = parts.slice(0, -1).join('-');
            const parentRow = document.getElementById(parentId);

            if (parentRow && parentRow.classList.contains('collapsed')) {
                parentRow.classList.remove('collapsed');
                
                document.querySelectorAll('tr').forEach(row => {
                    if (row.id.startsWith(parentId + '-') && row.id.split('-').length === parentId.split('-').length + 1) {
                        row.classList.remove('hidden');
                    }
                });

                expandParents(parentRow);
            }
        }

        function renderWorkoutTable(workout) {
            if (!workout || typeof workout !== 'object') {
                showError("Invalid workout data structure.");
                return;
            }
            currentWorkoutData = workout;
            workoutDisplay.innerHTML = ''; 

            const table = document.createElement('table');
            table.className = 'w-full text-xs border-collapse whitespace-nowrap workout-table';
            
            const thead = document.createElement('thead');
            thead.className = 'bg-gray-200 text-left sticky-header';
            
            // Header row - property names
            const trHead = document.createElement('tr');

            headers.forEach((header, index) => {
                const th = document.createElement('th');
                th.className = `p-3 font-semibold text-gray-700 border-b-2 border-gray-300 font-mono`;
                th.textContent = useFriendlyNames ? header.name : header.key;
                th.dataset.columnIndex = index;
                // Set conservative min widths so selects don't overflow, without over-widening columns
                const key = header.key;
                if (['type','positionType','iterationType','limits.type','intervalType','splitStepSpeed','voice'].includes(key)) {
                    th.style.minWidth = '7rem';
                } else if (['interval','intervalOffsetType','repeatCount.type'].includes(key)) {
                    th.style.minWidth = '6rem';
                } else if (['repeatCount.count','repeatCount.min','repeatCount.max','intervalOffsetMin','intervalOffsetMax','shotAnnouncementLeadTime','speechRate'].includes(key)) {
                    th.style.minWidth = '5rem';
                }
                if (['Auto Voice Split Step', 'Countdown', 'Skip at End'].includes(header.name)) {
                    th.classList.add('text-center');
                }
                trHead.appendChild(th);
            });
            thead.appendChild(trHead);

            // Wire up friendly name toggle (dropdown only)
            setTimeout(() => {
                const toggleDropdown = document.getElementById('friendly-toggle-dropdown');
                const syncAndRender = (checked) => {
                    useFriendlyNames = checked;
                    try { localStorage.setItem('useFriendlyNames', String(checked)); } catch (e) {}
                    // Re-render table to update headers and dropdown labels
                    renderWorkoutTable(currentWorkoutData);
                };
                if (toggleDropdown) {
                    toggleDropdown.addEventListener('change', (e) => {
                        const checked = e.target.checked;
                        syncAndRender(checked);
                    });
                }
            }, 0);
            
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            table.appendChild(tbody);

            // Root level defaults
            const rootDefaults = {
                voice: 'Default',
                speechRate: 1.0,
                interval: 5.0,
                intervalOffsetType: 'fixed',
                intervalOffset: { min: 0.0, max: 0.0 },
                autoVoiceSplitStep: true,
                shotAnnouncementLeadTime: 2.5,
                splitStepSpeed: 'auto-scale',
                iterationType: 'in-order',
                limits: { type: 'all-shots', value: null },
                countdown: false,
                skipAtEndOfWorkout: false,
                intervalType: 'fixed'
            };
            processAndRenderNode(workout, 'row', rootDefaults, tbody, 0, 0);
            
            workoutDisplay.appendChild(table);
            
            // If cut mode is active, enable clickable rows for deletion
            if (cutModeActive) {
                const tableEl = workoutDisplay.querySelector('table');
                if (tableEl) tableEl.classList.add('cut-mode');
                const rows = workoutDisplay.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    row.addEventListener('click', handleCutRowClick, true);
                });
            }
            
            // Restore green highlights for updated rows
            console.log('Restoring green highlights - updatedRows:', Array.from(updatedRows));
            updatedRows.forEach(nodeId => {
                const row = document.getElementById(nodeId);
                console.log(`Looking for row with ID: ${nodeId}, found:`, row);
                if (row) {
                    row.classList.add('update-row-highlight');
                    console.log(`Added update-row-highlight to row: ${nodeId}`);
                } else {
                    console.log(`Row not found for ID: ${nodeId}`);
                }
            });
            
            // Restore green highlights for updated cells
            console.log('Restoring green highlights - updatedCells:', Array.from(updatedCells.keys()));
            updatedCells.forEach((value, cellKey) => {
                // Handle cell keys with multiple hyphens (e.g., 'row-0-interval')
                let nodeId, propertyName;
                if (cellKey.startsWith('row-')) {
                    // Special case for workout element: 'row-0-interval' -> nodeId: 'row-0', property: 'interval'
                    const parts = cellKey.split('-');
                    if (parts.length >= 3) {
                        nodeId = parts.slice(0, 2).join('-'); // 'row-0'
                        propertyName = parts.slice(2).join('-'); // 'interval'
                    } else {
                        [nodeId, propertyName] = cellKey.split('-');
                    }
                } else {
                    // Regular case: 'shot_001-interval' -> nodeId: 'shot_001', property: 'interval'
                    const lastHyphenIndex = cellKey.lastIndexOf('-');
                    if (lastHyphenIndex !== -1) {
                        nodeId = cellKey.substring(0, lastHyphenIndex);
                        propertyName = cellKey.substring(lastHyphenIndex + 1);
                    } else {
                        [nodeId, propertyName] = cellKey.split('-');
                    }
                }
                
                const row = document.getElementById(nodeId);
                console.log(`Looking for cell - nodeId: ${nodeId}, property: ${propertyName}, row found:`, row);
                if (row) {
                    const cell = row.querySelector(`[data-property="${propertyName}"]`);
                    console.log(`Cell found for property ${propertyName}:`, cell);
                    if (cell) {
                        cell.classList.add('update-cell-highlight');
                        console.log(`Added update-cell-highlight to cell: ${nodeId}-${propertyName}`);
                    } else {
                        console.log(`Cell not found for property: ${propertyName} in row: ${nodeId}`);
                    }
                } else {
                    console.log(`Row not found for cell lookup: ${nodeId}`);
                }
            });
            
            // Initialize navigation indices
            const redRows = document.querySelectorAll('tr.select-row-highlight');
            updateNavIndex(-1, redRows.length);
            const greenCells = document.querySelectorAll('.update-cell-highlight');
            updateGreenNavIndex(-1, greenCells.length);
            
            // Enable row selection for saving
            enableRowSelectionForSaving();
            
            columnsDropdown.innerHTML = '';
            // Auto-size dropdown to fit longest label
            const longestLabel = headers.reduce((acc, h) => {
                const friendly = h.name;
                const raw = h.key;
                return Math.max(acc, (useFriendlyNames ? friendly : raw).length, friendly.length, raw.length);
            }, 0);
            const approxCharWidthPx = 8; // mono font approx
            const paddingPx = 32; // space for checkbox and padding
            const minWidthPx = 260; // ensure roomy default
            const computedWidth = Math.max(minWidthPx, longestLabel * approxCharWidthPx + paddingPx);
            columnsDropdown.style.minWidth = `${computedWidth}px`;
            // Friendly names toggle in dropdown
            const friendlyLabel = document.createElement('label');
            friendlyLabel.className = 'flex items-center justify-between px-2 py-1 rounded-md bg-gray-50 border border-gray-200 mb-1';
            friendlyLabel.innerHTML = `
                <span class="text-xs font-medium text-gray-700">Friendly names</span>
                <input id="friendly-toggle-dropdown" type="checkbox" class="form-checkbox h-4 w-4 text-blue-600 rounded" ${useFriendlyNames ? 'checked' : ''} />
            `;
            columnsDropdown.appendChild(friendlyLabel);

            headers.forEach((header, index) => {
                const label = document.createElement('label');
                label.className = 'flex items-center space-x-2 px-2 py-1 hover:bg-gray-100 rounded-md cursor-pointer';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.dataset.columnIndex = index;
                checkbox.className = 'form-checkbox h-4 w-4 text-blue-600 rounded';
                checkbox.addEventListener('change', (e) => {
                    const colIndex = e.target.dataset.columnIndex;
                    const table = workoutDisplay.querySelector('table');
                    const cells = table.querySelectorAll(`th:nth-child(${parseInt(colIndex) + 1}), td:nth-child(${parseInt(colIndex) + 1})`);
                    cells.forEach(cell => {
                        cell.style.display = e.target.checked ? '' : 'none';
                    });
                });
                label.appendChild(checkbox);
                const span = document.createElement('span');
                span.textContent = useFriendlyNames ? header.name : header.key;
                span.className = 'text-sm text-gray-700';
                label.appendChild(span);
                columnsDropdown.appendChild(label);
            });
        }

        let moveModeActive = false;
        let moveSelectedRowId = null;
        let moveSelectionLocked = false; // When true, hover will not change selection

        function processAndRenderNode(node, idPrefix, parentConfig, tbody, level, index) {
            // Use the same effective config calculation as the inheritance logic
            const effectiveConfig = calculateEffectiveConfigForNode(node, parentConfig);
            const nodeId = `${idPrefix}-${index}`;
            const hasChildren = Array.isArray(node.patterns) || Array.isArray(node.entries);

            // Set the nodeId consistently for tracking
            node.nodeId = nodeId;

            const tr = document.createElement('tr');
            tr.id = node.id || nodeId;
            if (idPrefix !== 'row') {
                tr.setAttribute('data-parent-id', idPrefix);
            }
            
            console.log('Creating row with ID:', tr.id, 'for node:', node.name || node.type);
            
            let bgColor = '';
            if (node.type === 'Workout') bgColor = 'bg-red-100';
            if (node.type === 'Pattern') bgColor = 'bg-purple-100';
            if (node.type === 'Shot' || node.type === 'Message') bgColor = 'bg-blue-100';
            tr.className = `border-b border-gray-200 hover:bg-gray-100 ${bgColor}`;
            

            // Move-mode row hover selection (preview) + click sets selection
            tr.addEventListener('click', (e) => {
                if (!moveModeActive) return;
                // Avoid toggles or inputs
                if (e.target.closest('a, button, .toggle-icon')) return;
                selectRowForMove(tr.id);
                moveSelectionLocked = true; // lock selection for this session
                e.stopPropagation();
            }, true);
            tr.addEventListener('mouseenter', () => {
                if (!moveModeActive || moveSelectionLocked) return;
                selectRowForMove(tr.id);
            });

            if (hasChildren) {
                tr.classList.add('collapsible');
            }
            
            const isInherited = (prop) => {
                // For direct properties like name, type, positionType, they are never inherited
                if (!prop.includes('.')) {
                    return false;
                }
                
                // For config properties, check if the value matches the inherited value
                const pathParts = prop.split('.');
                let target = node;
                
                // Navigate to the parent object (e.g., node.config)
                for (let i = 0; i < pathParts.length - 1; i++) {
                    if (!target || !target.hasOwnProperty(pathParts[i])) {
                        return true; // Inherited if parent object doesn't exist
                    }
                    target = target[pathParts[i]];
                }
                
                // Check if the final property exists
                const finalProperty = pathParts[pathParts.length - 1];
                
                // If the property doesn't exist on this node, it's inherited
                if (!target || !target.hasOwnProperty(finalProperty)) {
                    return true;
                }
                
                // If the property exists, check if its value matches the inherited value
                const currentValue = target[finalProperty];
                const inheritedValue = getInheritedValue(node, prop);
                
                // Return true if values match (showing as inherited/grey)
                if (inheritedValue === undefined) {
                    return false;
                }
                
                // Handle numeric values with type coercion (e.g., "5.00" === 5.0)
                if (typeof inheritedValue === 'number' && typeof currentValue === 'string') {
                    return parseFloat(currentValue) === inheritedValue;
                }
                if (typeof inheritedValue === 'string' && typeof currentValue === 'number') {
                    return inheritedValue === currentValue.toString();
                }
                
                return currentValue === inheritedValue;
            };
            const inheritedClass = 'text-gray-400';
            const na = '—';

            const createCell = (content, inherited, center = false, editable = false, propertyPath = null) => {
                const td = document.createElement('td');
                td.className = 'p-3 align-top font-mono';
                if (inherited) td.classList.add(inheritedClass);
                if (center) td.classList.add('text-center');
                if (propertyPath) {
                    const propertyName = extractPropertyNameForCell(propertyPath);
                    td.setAttribute('data-property', propertyName);
                }
                if (editable) {
                    td.classList.add('editable-cell');
                    td.addEventListener('click', (e) => {
                        if (e.target.closest('a, button')) return;
                        

                        
                        makeCellEditable(td, node.id || nodeId, propertyPath, content);
                    });
                }
                td.innerHTML = content;
                return td;
            };
            
            const createIconCell = (showIcon, title, iconSvg, inherited, editable = false, propertyPath = null) => {
                const td = document.createElement('td');
                td.className = 'p-3 align-top';
                if (propertyPath) {
                    const propertyName = extractPropertyNameForCell(propertyPath);
                    td.setAttribute('data-property', propertyName);
                }
                if (editable) {
                    td.classList.add('editable-cell');
                    td.addEventListener('click', (e) => {
                        if (e.target.closest('a, button')) return;
                        const currentValue = showIcon ? 'true' : 'false';
                        makeCellEditable(td, node.id || nodeId, propertyPath, currentValue);
                    });
                }
                if (showIcon) {
                    td.innerHTML = iconSvg;
                    td.title = title;
                    const svg = td.querySelector('svg');
                    if (svg) {
                        if (inherited) {
                            svg.classList.add(inheritedClass);
                        } else {
                            svg.classList.add('text-green-600');
                        }
                    }
                } else {
                    td.innerHTML = crossIcon;
                    td.title = title;
                    const svg = td.querySelector('svg');
                    if (svg) {
                        if (inherited) {
                            svg.classList.add(inheritedClass);
                        } else {
                            svg.classList.add('text-red-600');
                        }
                    }
                }
                return td;
            };
            
            const checkIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
            const crossIcon = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M6.293 6.293a1 1 0 011.414 0L10 8.586l2.293-2.293a1 1 0 111.414 1.414L11.414 10l2.293 2.293a1 1 0 01-1.414 1.414L10 11.414l-2.293 2.293a1 1 0 01-1.414-1.414L8.586 10 6.293 7.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg>`;

            const formatNumber = (num) => {
                if (typeof num !== 'number') return num;
                return num.toFixed(2);
            };

            const formatIntervalOffset = (num) => {
                if (typeof num !== 'number') return num;
                return num.toFixed(2);
            };

            // --- Column Data ---
            const tdName = document.createElement('td');
            tdName.className = 'p-3 font-medium align-top editable-cell';
            tdName.setAttribute('data-property', 'name');
            tdName.style.paddingLeft = `${0.75 + level * 1.5}rem`;
            const toggleIcon = hasChildren
                ? `<span id="toggle-icon-${nodeId}" class="toggle-icon inline-block w-[1.5em] select-none" tabindex="0" role="button" aria-label="Toggle children">▾</span>`
                : `<span class="toggle-icon inline-block w-[1.5em]"></span>`;
            let nameContent = `<span class="font-bold font-sans">${node.name || node.type}</span>`;
            tdName.innerHTML = `${toggleIcon}${nameContent}`;
            
            // Add click listener to the chevron icon for collapsing/expanding
            if (hasChildren) {
                const toggleIconElement = tdName.querySelector('.toggle-icon');
                if (toggleIconElement) {
                    toggleIconElement.style.cursor = 'pointer';
                    const activateToggle = (e) => {
                        e.stopPropagation();
                        toggleChildren(node.id || nodeId);
                    };
                    toggleIconElement.addEventListener('click', activateToggle);
                    toggleIconElement.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') activateToggle(e);
                    });
                }
                
            }
            
            tdName.addEventListener('click', (e) => {
                if (e.target.closest('a, button, .toggle-icon, .grip-handle')) return;
                
                // Check if click was on the message text for Message type
                if (node.type === 'Message' && e.target.classList.contains('text-gray-600')) {
                    // Let the message span click handler handle this
                    return;
                }
                
                if (node.type === 'Shot') {
                    makeNameEditableWithSuggestions(tdName, nodeId, 'name', node.name || node.type);
                } else {
                    makeCellEditable(tdName, nodeId, 'name', node.name || node.type);
                }
            });
            
            // Message will be shown in dedicated column now
            tr.appendChild(tdName);
            
            tr.appendChild(createCell(node.type || na, false, false, true, 'type')); // Type (dropdown)
            
            // Position Type
            tr.appendChild(createCell(
                node.positionType || na,
                false,
                false,
                node.type !== 'Workout',
                'positionType'
            )); // Position Type (dropdown)
            
            let intervalText = na;
            if (node.type === 'Message') {
                intervalText = (node.config && node.config.interval !== undefined) ? node.config.interval : na;
            } else {
                intervalText = effectiveConfig.interval ?? na;
                if (typeof intervalText === 'number') intervalText = formatNumber(intervalText);
            }
            tr.appendChild(createCell(intervalText, isInherited('config.interval'), false, true, 'config.interval'));

            // Offset group (Type / Min / Max)
            tr.appendChild(createCell(
                node.type === 'Message' ? '—' : (effectiveConfig.intervalOffsetType || na),
                isInherited('config.intervalOffsetType'),
                false,
                node.type !== 'Message',
                'config.intervalOffsetType'
            )); // Offset Type (dropdown)

            // Interval Offset Min
            let offsetMinText = na;
            if (effectiveConfig.intervalOffset && effectiveConfig.intervalOffset.min !== undefined) {
                offsetMinText = formatIntervalOffset(effectiveConfig.intervalOffset.min);
            }
            if (node.type === 'Message') offsetMinText = '—';
            tr.appendChild(createCell(offsetMinText, isInherited('config.intervalOffset.min'), false, node.type !== 'Message', 'config.intervalOffset.min'));

            // Interval Offset Max
            let offsetMaxText = na;
            if (effectiveConfig.intervalOffset && effectiveConfig.intervalOffset.max !== undefined) {
                offsetMaxText = formatIntervalOffset(effectiveConfig.intervalOffset.max);
            }
            if (node.type === 'Message') offsetMaxText = '—';
            tr.appendChild(createCell(offsetMaxText, isInherited('config.intervalOffset.max'), false, node.type !== 'Message', 'config.intervalOffset.max'));

            // Remove legacy single repeat column and editors

            // Repeat subfields (type/count/min/max) for visibility and quick inline edits
            let repeatType = na, repeatFixed = na, repeatMin = na, repeatMax = na;
            if (node.type === 'Shot' || node.type === 'Pattern') {
                const rc = effectiveConfig.repeatCount;
                if (rc === null || rc === undefined) {
                    // No repeat: show — for all fields
                    repeatType = '—';
                    repeatFixed = '—';
                    repeatMin = '—';
                    repeatMax = '—';
                } else if (typeof rc === 'object' && rc !== null) {
                    repeatType = rc.type ?? na;
                    if (rc.type === 'fixed') repeatFixed = rc.count ?? na;
                    if (rc.type === 'random') {
                        repeatMin = rc.min ?? na;
                        repeatMax = rc.max ?? na;
                    }
                }
            }
            tr.appendChild(createCell(node.type === 'Message' ? '—' : repeatType, isInherited('config.repeatCount'), false, node.type !== 'Message', 'config.repeatCount.type'));
            tr.appendChild(createCell(node.type === 'Message' ? '—' : repeatFixed, isInherited('config.repeatCount'), false, node.type !== 'Message', 'config.repeatCount.count'));
            tr.appendChild(createCell(node.type === 'Message' ? '—' : repeatMin, isInherited('config.repeatCount'), false, node.type !== 'Message', 'config.repeatCount.min'));
            tr.appendChild(createCell(node.type === 'Message' ? '—' : repeatMax, isInherited('config.repeatCount'), false, node.type !== 'Message', 'config.repeatCount.max'));
            tr.appendChild(createCell(
                (node.type === 'Workout' || node.type === 'Pattern') ? (effectiveConfig.iterationType || na) : '—',
                isInherited('config.iterationType'),
                false,
                (node.type === 'Workout' || node.type === 'Pattern'),
                'config.iterationType'
            )); // Iteration Type (dropdown)
            
            const limitTypeCell = (node.type === 'Workout' || node.type === 'Pattern')
                ? createCell(na, isInherited('config.limits.type'), false, true, 'config.limits.type')
                : createCell('—', isInherited('config.limits.type'), false, false, 'config.limits.type');
            const limitValCell = (node.type === 'Workout' || node.type === 'Pattern')
                ? createCell(na, isInherited('config.limits.value'), false, true, 'config.limits.value')
                : createCell('—', isInherited('config.limits.value'), false, false, 'config.limits.value');
            if ((node.type === 'Workout' || node.type === 'Pattern') && effectiveConfig.limits) {
                const { type, value } = effectiveConfig.limits;
                limitTypeCell.innerHTML = type.replace(/-/g, ' ') || na;
                limitValCell.innerHTML = value !== null ? value : na;
                if (type === 'all-shots') limitValCell.innerHTML = na;
            }
            tr.appendChild(limitTypeCell);
            tr.appendChild(limitValCell);

            

            // Message text column
            tr.appendChild(createCell(node.type === 'Message' ? (effectiveConfig.message || na) : '—', isInherited('config.message'), false, node.type === 'Message', 'config.message'));
            
            // Message Interval Type (for Message only)
            tr.appendChild(createCell(node.type === 'Message' ? (effectiveConfig.intervalType || 'fixed') : '—', isInherited('config.intervalType'), false, node.type === 'Message', 'config.intervalType'));
            
            // Countdown / Skip At End (Message only) as check icons
            if (node.type === 'Message') {
                tr.appendChild(createIconCell(
                    effectiveConfig.countdown === true,
                    effectiveConfig.countdown === true ? 'true' : 'false',
                    checkIcon,
                    isInherited('config.countdown'),
                    true,
                    'config.countdown'
                ));
                tr.appendChild(createIconCell(
                    effectiveConfig.skipAtEndOfWorkout === true,
                    effectiveConfig.skipAtEndOfWorkout === true ? 'true' : 'false',
                    checkIcon,
                    isInherited('config.skipAtEndOfWorkout'),
                    true,
                    'config.skipAtEndOfWorkout'
                ));
            } else {
                tr.appendChild(createCell('—', isInherited('config.countdown'), false, false, 'config.countdown'));
                tr.appendChild(createCell('—', isInherited('config.skipAtEndOfWorkout'), false, false, 'config.skipAtEndOfWorkout'));
            }
            
            // Announcement Lead Time (Shot only)
            let leadTimeText = node.type === 'Shot' ? effectiveConfig.shotAnnouncementLeadTime ?? na : (node.type === 'Message' ? '—' : na);
            if(typeof leadTimeText === 'number') leadTimeText = formatNumber(leadTimeText);
            tr.appendChild(createCell(leadTimeText, isInherited('config.shotAnnouncementLeadTime'), false, node.type !== 'Message', 'config.shotAnnouncementLeadTime'));
            
            // Auto Voice Split Step (editable for Workout, Pattern, Shot; not for Message)
            if (node.type === 'Message') {
                tr.appendChild(createCell('—', isInherited('config.autoVoiceSplitStep'), false, false, 'config.autoVoiceSplitStep'));
            } else {
                tr.appendChild(createIconCell(
                    effectiveConfig.autoVoiceSplitStep === true,
                    effectiveConfig.autoVoiceSplitStep === true ? 'true' : 'false',
                    checkIcon,
                    isInherited('config.autoVoiceSplitStep'),
                    node.type !== 'Message',
                    'config.autoVoiceSplitStep'
                ));
            }
            
            // Speech Rate
            let speechRateText = effectiveConfig.speechRate ?? na;
            if(typeof speechRateText === 'number') speechRateText = formatNumber(speechRateText);
            tr.appendChild(createCell(speechRateText, isInherited('config.speechRate'), false, true, 'config.speechRate'));
            
            // Split Step Speed (Workout, Pattern, and Shot only)
            tr.appendChild(createCell(node.type === 'Message' ? '—' : (node.type === 'Workout' || node.type === 'Pattern' || node.type === 'Shot' ? (effectiveConfig.splitStepSpeed || na) : na), isInherited('config.splitStepSpeed'), false, node.type === 'Workout' || node.type === 'Pattern' || node.type === 'Shot', 'config.splitStepSpeed'));
            
            // Voice
            tr.appendChild(createCell(effectiveConfig.voice || na, isInherited('config.voice'), false, true, 'config.voice'));
            
            // Identifier at end
            tr.appendChild(createCell(
                node.id || na,
                false,
                false,
                node.type !== 'Workout',
                'id'
            ));

            tbody.appendChild(tr);

            const children = node.patterns || node.entries;
            if (hasChildren && children.length > 0) {
                children.forEach((child, childIndex) => processAndRenderNode(child, node.id || nodeId, effectiveConfig, tbody, level + 1, childIndex));
            }
        }

        function toggleChildren(parentId) {
            const parentRow = document.getElementById(parentId);
            const children = document.querySelectorAll(`tr[data-parent-id="${parentId}"]`);
            if (!children.length) return;
            
            parentRow.classList.toggle('collapsed');
            const isCollapsing = parentRow.classList.contains('collapsed');

            document.querySelectorAll('tr').forEach(row => {
                if (row.getAttribute('data-parent-id') === parentId) {
                    row.classList.toggle('hidden', isCollapsing);
                    if (isCollapsing && row.classList.contains('collapsible')) {
                        hideAllDescendants(row.id);
                    }
                }
            });
        }

        function hideAllDescendants(parentId) {
            const parentRow = document.getElementById(parentId);
            if(parentRow && !parentRow.classList.contains('collapsed')) {
                 parentRow.classList.add('collapsed');
            }
            document.querySelectorAll('tr').forEach(row => {
                if(row.getAttribute('data-parent-id') === parentId) {
                    row.classList.add('hidden');
                }
            });
        }

        function showError(message) {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        function hideError() {
            errorMessage.classList.add('hidden');
        }
        
        function showSuccessMessage(message) {
            // Create a temporary success message
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transform transition-all duration-300 translate-x-full';
            successDiv.textContent = message;
            
            document.body.appendChild(successDiv);
            
            // Animate in
            setTimeout(() => {
                successDiv.classList.remove('translate-x-full');
            }, 100);
            
            // Animate out and remove
            setTimeout(() => {
                successDiv.classList.add('translate-x-full');
                setTimeout(() => {
                    if (document.body.contains(successDiv)) {
                        document.body.removeChild(successDiv);
                    }
                }, 300);
            }, 3000);
        }

        // --- Cell Editing Functions ---
        
        function makeCellEditable(cell, nodeId, propertyPath, currentValue) {
            if (cell.classList.contains('editing')) return;
            

            
            cell.classList.add('editing');
            const originalContent = cell.innerHTML;
            
            // Check if this field should use a dropdown
            let dropdownOptions = getDropdownOptions(propertyPath);
            
            if (dropdownOptions) {
                // Create dropdown
                const select = document.createElement('select');
                select.className = 'font-mono w-full border-none bg-transparent outline-none';
                
                // Add empty option for clearing the value, only when optional for this node
                // Skip for config.repeatCount.type since it already has the em dash option in the main dropdown
                if (isOptionalDropdownProperty(propertyPath, findNodeById(currentWorkoutData, nodeId)) && propertyPath !== 'config.repeatCount.type') {
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    emptyOption.textContent = '—';
                    select.appendChild(emptyOption);
                }
                
                // Add dropdown options
                // Special-case: prevent adding another Workout node if one already exists
                const editingNode = findNodeById(currentWorkoutData, nodeId);
                if (propertyPath === 'type' && editingNode !== currentWorkoutData) {
                    dropdownOptions = dropdownOptions.filter(opt => opt.value !== 'Workout');
                }
                dropdownOptions.forEach(option => {
                    const optionElement = document.createElement('option');
                    optionElement.value = option.value;
                    optionElement.textContent = option.label;
                    if (option.value === currentValue || option.value === currentValue.toString() || 
                        (option.value === 'true' && currentValue === true) || 
                        (option.value === 'false' && currentValue === false)) {
                        optionElement.selected = true;
                    }
                    select.appendChild(optionElement);
                });

                // Do not resize select on activation; column widths are sized via header min-widths
                
                let editingHandled = false;
                const finishEditing = (save = true) => {
                    if (editingHandled) return; // Prevent multiple calls
                    editingHandled = true;
                    
                    // Check if cell is still in the DOM
                    if (!document.contains(cell)) {
                        return; // Cell was removed during re-render
                    }
                    
                    cell.classList.remove('editing');
                    if (save) {
                        const newValue = select.value;
                        if (newValue === '') {
                            // Clear property to inherit/omit
                            const node = findNodeById(currentWorkoutData, nodeId);
                            if (node && isOptionalDropdownProperty(propertyPath, node)) {
                                removeProperty(node, propertyPath);
                                isProgrammaticUpdate = true;
                                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                                renderWorkoutTable(currentWorkoutData);
                                setTimeout(() => { isProgrammaticUpdate = false; }, 100);
                                showSuccessMessage(`Cleared ${propertyPath}`);
                                return;
                            }
                        }
                        if (newValue !== currentValue) {
                            updateNodeProperty(nodeId, propertyPath, newValue);
                            // Don't update cell.innerHTML here as the table will be re-rendered
                        } else {
                            cell.innerHTML = originalContent;
                        }
                    } else {
                        cell.innerHTML = originalContent;
                    }
                };
                
                select.addEventListener('change', () => finishEditing(true));
                select.addEventListener('blur', () => finishEditing(true));
                select.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        finishEditing(false);
                    }
                });
                
                try {
                    cell.innerHTML = '';
                    cell.appendChild(select);
                    select.focus();
                } catch (error) {
                    console.warn('Cell was removed during editing setup:', error);
                }
            } else {
                // Create text input for free-form fields
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentValue === '—' ? '' : currentValue;
                input.className = 'font-mono w-full border-none bg-transparent outline-none';
                
                let editingHandled = false;
                const finishEditing = (save = true) => {
                    if (editingHandled) return; // Prevent multiple calls
                    editingHandled = true;
                    
                    // Check if cell is still in the DOM
                    if (!document.contains(cell)) {
                        return; // Cell was removed during re-render
                    }
                    
                    cell.classList.remove('editing');
                    if (save) {
                        const newValue = input.value.trim();
                        if (newValue !== currentValue && newValue !== '') {
                            updateNodeProperty(nodeId, propertyPath, newValue);
                            // Don't update cell.innerHTML here as the table will be re-rendered
                        } else {
                            cell.innerHTML = originalContent;
                        }
                    } else {
                        cell.innerHTML = originalContent;
                    }
                };
                
                input.addEventListener('blur', () => finishEditing(true));
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEditing(true);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        finishEditing(false);
                    }
                });
                
                try {
                    cell.innerHTML = '';
                    cell.appendChild(input);
                    input.focus();
                    input.select();
                } catch (error) {
                    console.warn('Cell was removed during editing setup:', error);
                }
            }
        }
        
        function getDropdownOptions(propertyPath) {
            const options = {
                'type': [
                    { value: 'Workout', label: 'Workout' },
                    { value: 'Pattern', label: 'Pattern' },
                    { value: 'Shot', label: 'Shot' },
                    { value: 'Message', label: 'Message' }
                ],
                'positionType': [
                    { value: 'normal', label: 'normal' },
                    { value: 'linked', label: 'linked' },
                    { value: 'last', label: 'last' },
                    { value: '1', label: '1' },
                    { value: '2', label: '2' },
                    { value: '3', label: '3' },
                    { value: '4', label: '4' },
                    { value: '5', label: '5' }
                ],
                'config.repeatCount.type': [
                    { value: '—', label: '—' },
                    { value: 'fixed', label: 'fixed' },
                    { value: 'random', label: 'random' }
                ],
                'config.iterationType': [
                    { value: 'in-order', label: 'in-order' },
                    { value: 'shuffle', label: 'shuffle' }
                ],
                'config.limits.type': [
                    { value: 'all-shots', label: 'all-shots' },
                    { value: 'shot-limit', label: 'shot-limit' },
                    { value: 'time-limit', label: 'time-limit' }
                ],
                'config.intervalOffsetType': [
                    { value: 'fixed', label: 'fixed' },
                    { value: 'random', label: 'random' }
                ],
                'config.splitStepSpeed': [
                    { value: 'none', label: 'none' },
                    { value: 'slow', label: 'slow' },
                    { value: 'medium', label: 'medium' },
                    { value: 'fast', label: 'fast' },
                    { value: 'random', label: 'random' },
                    { value: 'auto-scale', label: 'auto-scale' }
                ],
                'config.intervalType': [
                    { value: 'fixed', label: 'fixed' },
                    { value: 'additional', label: 'additional' }
                ],
                'config.autoVoiceSplitStep': [
                    { value: 'true', label: 'true' },
                    { value: 'false', label: 'false' }
                ],
                'config.countdown': [
                    { value: 'true', label: 'true' },
                    { value: 'false', label: 'false' }
                ],
                'config.skipAtEndOfWorkout': [
                    { value: 'true', label: 'true' },
                    { value: 'false', label: 'false' }
                ]
            };
            
            return options[propertyPath] || null;
        }

        function isOptionalDropdownProperty(propertyPath, node) {
            // Fields that may be omitted (inherit/absent) per json-spec.md
            // Required fields should not offer a clearing option
            // - iterationType: required for Workout and Pattern
            // - limits.type: required for Workout and Pattern
            // - positionType: required for Pattern, Shot, Message (not applicable to Workout)
            // Optional examples: intervalOffsetType, splitStepSpeed (shot), intervalType (message), repeatCount.type
            if (propertyPath === 'config.iterationType') {
                return false; // required where applicable
            }
            if (propertyPath === 'config.limits.type') {
                return false; // required where applicable
            }
            if (propertyPath === 'positionType') {
                // positionType required for Pattern/Shot/Message
                return node.type === 'Workout';
            }
            // Optional list
            const optionalProps = new Set([
                'config.intervalOffsetType',
                'config.splitStepSpeed',
                'config.intervalType',
                'config.repeatCount.type'
            ]);
            if (optionalProps.has(propertyPath)) {
                // Further restrict by node type when property only applies conditionally
                if (propertyPath === 'config.splitStepSpeed') return node.type === 'Workout' || node.type === 'Pattern' || node.type === 'Shot';
                if (propertyPath === 'config.intervalType') return node.type === 'Message';
                return true;
            }
            return false;
        }
        
        function getCommonShotNames() {
            return [
                'Forehand Drive', 'Backhand Drive', 'Forehand Drop', 'Backhand Drop',
                'Forehand Boast', 'Backhand Boast', 'Forehand Lob', 'Backhand Lob',
                'Forehand Cross Court', 'Backhand Cross Court', 'Forehand Straight', 'Backhand Straight',
                'Forehand Kill', 'Backhand Kill', 'Forehand Volley', 'Backhand Volley',
                'Front Left', 'Front Right', 'Mid Left', 'Mid Right', 'Back Left', 'Back Right',
                '1L', '1R', '2L', '2R', '3L', '3R', '4L', '4R', '5L', '5R', '6L', '6R'
            ];
        }
        
        function makeNameEditableWithSuggestions(cell, nodeId, propertyPath, currentValue) {
            if (cell.classList.contains('editing')) return;
            
            cell.classList.add('editing');
            const originalContent = cell.innerHTML;
            
            // Create container for input and suggestions
            const container = document.createElement('div');
            container.className = 'relative w-full';
            
            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentValue === '—' ? '' : currentValue;
            input.className = 'font-mono w-full border-none bg-transparent outline-none';
            input.placeholder = 'Type shot name...';
            
            // Create suggestions dropdown
            const suggestionsDiv = document.createElement('div');
            suggestionsDiv.className = 'absolute top-full left-0 right-0 bg-white border border-gray-300 rounded-lg shadow-lg z-50 max-h-40 overflow-y-auto hidden';
            
            const commonNames = getCommonShotNames();
            commonNames.forEach(name => {
                const suggestionItem = document.createElement('div');
                suggestionItem.className = 'px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm';
                suggestionItem.textContent = name;
                suggestionItem.addEventListener('click', () => {
                    input.value = name;
                    suggestionsDiv.classList.add('hidden');
                    finishEditing(true);
                });
                suggestionsDiv.appendChild(suggestionItem);
            });
            
            container.appendChild(input);
            container.appendChild(suggestionsDiv);
            
            let editingHandled = false;
            const finishEditing = (save = true) => {
                if (editingHandled) return; // Prevent multiple calls
                editingHandled = true;
                
                // Check if cell is still in the DOM
                if (!document.contains(cell)) {
                    return; // Cell was removed during re-render
                }
                
                cell.classList.remove('editing');
                if (save) {
                    const newValue = input.value.trim();
                    if (newValue !== currentValue && newValue !== '') {
                        updateNodeProperty(nodeId, propertyPath, newValue);
                    } else {
                        cell.innerHTML = originalContent;
                    }
                } else {
                    cell.innerHTML = originalContent;
                }
            };
            
            // Show/hide suggestions based on input
            input.addEventListener('input', () => {
                const value = input.value.toLowerCase();
                const matchingSuggestions = suggestionsDiv.querySelectorAll('div');
                
                matchingSuggestions.forEach(item => {
                    const text = item.textContent.toLowerCase();
                    if (text.includes(value) && value.length > 0) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = 'none';
                    }
                });
                
                const visibleSuggestions = Array.from(matchingSuggestions).filter(item => item.style.display !== 'none');
                suggestionsDiv.classList.toggle('hidden', visibleSuggestions.length === 0);
            });
            
            input.addEventListener('focus', () => {
                if (input.value.length > 0) {
                    suggestionsDiv.classList.remove('hidden');
                }
            });
            
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    suggestionsDiv.classList.add('hidden');
                    finishEditing(true);
                }, 200);
            });
            
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    suggestionsDiv.classList.add('hidden');
                    finishEditing(true);
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    suggestionsDiv.classList.add('hidden');
                    finishEditing(false);
                }
            });
            
            try {
                cell.innerHTML = '';
                cell.appendChild(container);
                input.focus();
                input.select();
            } catch (error) {
                console.warn('Cell was removed during editing setup:', error);
            }
        }
        
        function updateNodeProperty(nodeId, propertyPath, newValue) {
            console.log('updateNodeProperty called:', { nodeId, propertyPath, newValue });
            if (!currentWorkoutData) return;
            
            const node = findNodeById(currentWorkoutData, nodeId);
            console.log('Found node:', { nodeId, node: node ? { type: node.type, name: node.name } : null });
            if (!node) return;
            

            
            // Handle inheritance logic
            const inheritedValue = getInheritedValue(node, propertyPath);
            
            // Convert newValue to the appropriate type for comparison
            let convertedNewValue = newValue;
            if (propertyPath.includes('autoVoiceSplitStep') || propertyPath.includes('countdown') || propertyPath.includes('skipAtEndOfWorkout')) {
                convertedNewValue = newValue.toLowerCase() === 'true';
            } else if (propertyPath === 'config.interval') {
                // Handle interval differently for Messages vs Shots/Workouts
                if (node.type === 'Message') {
                    // Messages use MM:SS string format
                    if (/^\d{1,2}:\d{2}$/.test(newValue)) {
                        convertedNewValue = newValue; // Keep as string
                    } else {
                        // Try to convert numeric seconds to MM:SS format for comparison
                        const seconds = parseFloat(newValue);
                        if (isNaN(seconds) || seconds < 0 || seconds > 300) {
                            showError(`Invalid interval for Message. Use MM:SS format (e.g., "01:00", "00:30") or seconds (0-300).`);
                            return;
                        }
                        const minutes = Math.floor(seconds / 60);
                        const remainingSeconds = Math.floor(seconds % 60);
                        convertedNewValue = `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
                    }
                } else {
                    // Shots and Workouts use numeric seconds
                    convertedNewValue = parseFloat(newValue);
                    if (isNaN(convertedNewValue)) {
                        showError(`Invalid number: ${newValue}`);
                        return;
                    }
                }
            } else if (propertyPath === 'config.speechRate' || propertyPath === 'config.shotAnnouncementLeadTime' || propertyPath === 'config.repeatCount' || propertyPath === 'repeatCount') {
                convertedNewValue = parseFloat(newValue);
                // Handle NaN case
                if (isNaN(convertedNewValue)) {
                    showError(`Invalid number: ${newValue}`);
                    return;
                }
            }
            

            
            // If the new value matches the inherited value, remove the property to inherit
            if (convertedNewValue === inheritedValue) {
                removeProperty(node, propertyPath);
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    isProgrammaticUpdate = false;
                }, 100);
                showSuccessMessage(`Removed ${propertyPath} to inherit value: ${inheritedValue}`);
                return;
            }
            
            // Handle special cases
            if (propertyPath === 'config.intervalOffset.min' || propertyPath === 'config.intervalOffset.max') {
                // Handle interval offset min/max separately
                const numValue = parseFloat(newValue);
                if (isNaN(numValue)) {
                    showError(`Invalid number: ${newValue}`);
                    return;
                }
                
                if (!node.config) node.config = {};
                if (!node.config.intervalOffset) node.config.intervalOffset = {};
                
                if (propertyPath === 'config.intervalOffset.min') {
                    node.config.intervalOffset.min = numValue;
                    // If switching to fixed type, ensure max equals min
                    if (node.config.intervalOffsetType === 'fixed') {
                        node.config.intervalOffset.max = numValue;
                    }
                } else {
                    node.config.intervalOffset.max = numValue;
                    // If switching to fixed type, ensure min equals max
                    if (node.config.intervalOffsetType === 'fixed') {
                        node.config.intervalOffset.min = numValue;
                    }
                }
                
                // Track the updated row and cell for green highlighting
                let trackingNodeId;
                if (node.type === 'Workout') {
                    trackingNodeId = 'row-0'; // Special case for workout element
                } else {
                    trackingNodeId = node.id || node.nodeId;
                }
                updatedRows.add(trackingNodeId);
                const propertyName = extractPropertyNameForCell(propertyPath);
                const cellKey = `${trackingNodeId}-${propertyName}`;
                updatedCells.set(cellKey, true);
                
                // Also track by property path and node identifier for manual JSON editing
                const nodeIdentifier = node.id || node.name || node.type;
                const propertyKey = `${node.type}-${nodeIdentifier}-${propertyPath}`;
                updatedProperties.set(propertyKey, true);
                
                // Special handling for interval offset min/max to ensure both are tracked
                if (propertyPath === 'config.intervalOffset.min' || propertyPath === 'config.intervalOffset.max') {
                    const otherPropertyPath = propertyPath === 'config.intervalOffset.min' ? 'config.intervalOffset.max' : 'config.intervalOffset.min';
                    const otherPropertyKey = `${node.type}-${nodeIdentifier}-${otherPropertyPath}`;
                    updatedProperties.set(otherPropertyKey, true);
                }
                
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    isProgrammaticUpdate = false;
                }, 100);
                showSuccessMessage(`Updated ${propertyPath.split('.').pop()} to ${numValue.toFixed(2)}`);
                return;
            }
            
            if (propertyPath === 'config.limits.type' || propertyPath === 'config.limits.value') {
                // Handle limits object
                if (!node.config) node.config = {};
                if (!node.config.limits) node.config.limits = {};
                
                if (propertyPath === 'config.limits.type') {
                    node.config.limits.type = newValue.replace(/\s+/g, '-');
                } else {
                    // Handle limits.value - can be number (for shot-limit) or MM:SS string (for time-limit)
                    if (node.config.limits.type === 'time-limit') {
                        // For time-limit, validate MM:SS format and store as string
                        if (/^\d{1,2}:\d{2}$/.test(newValue)) {
                            node.config.limits.value = newValue;
                        } else {
                            showError(`Invalid time format. Use MM:SS format (e.g., "01:00", "00:30")`);
                            return;
                        }
                    } else {
                        // For shot-limit, parse as number
                        const numValue = parseFloat(newValue);
                        if (isNaN(numValue)) {
                            showError(`Invalid number: ${newValue}`);
                            return;
                        }
                        node.config.limits.value = numValue;
                    }
                }
                
                // Track the updated row and cell for green highlighting
                let trackingNodeId;
                if (node.type === 'Workout') {
                    trackingNodeId = 'row-0'; // Special case for workout element
                } else {
                    trackingNodeId = node.id || node.nodeId;
                }
                updatedRows.add(trackingNodeId);
                const propertyName = extractPropertyNameForCell(propertyPath);
                const cellKey = `${trackingNodeId}-${propertyName}`;
                updatedCells.set(cellKey, true);
                
                // Also track by property path and node identifier for manual JSON editing
                const nodeIdentifier = node.id || node.name || node.type;
                const propertyKey = `${node.type}-${nodeIdentifier}-${propertyPath}`;
                updatedProperties.set(propertyKey, true);
                
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    isProgrammaticUpdate = false;
                }, 100);
                showSuccessMessage(`Updated ${propertyPath.split('.').pop()} to ${newValue}`);
                return;
            }
            
            if (propertyPath === 'config.intervalOffsetType') {
                // Handle interval offset type
                if (!node.config) node.config = {};
                node.config.intervalOffsetType = newValue;
                
                // If switching to fixed, ensure min and max are the same
                if (newValue === 'fixed' && node.config.intervalOffset) {
                    const currentMin = node.config.intervalOffset.min || 0;
                    node.config.intervalOffset.min = currentMin;
                    node.config.intervalOffset.max = currentMin;
                }
                
                // Track the updated row and cell for green highlighting
                let trackingNodeId;
                if (node.type === 'Workout') {
                    trackingNodeId = 'row-0'; // Special case for workout element
                } else {
                    trackingNodeId = node.id || node.nodeId;
                }
                updatedRows.add(trackingNodeId);
                const propertyName = extractPropertyNameForCell(propertyPath);
                const cellKey = `${trackingNodeId}-${propertyName}`;
                updatedCells.set(cellKey, true);
                
                // Also track by property path and node identifier for manual JSON editing
                const nodeIdentifier = node.id || node.name || node.type;
                const propertyKey = `${node.type}-${nodeIdentifier}-${propertyPath}`;
                updatedProperties.set(propertyKey, true);
                
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    isProgrammaticUpdate = false;
                }, 100);
                showSuccessMessage(`Updated interval offset type to ${newValue}`);
                return;
            }
            
            // Handle repeatCount structured fields (type/count/min/max)
            if (
                propertyPath === 'config.repeatCount.type' ||
                propertyPath === 'config.repeatCount.count' ||
                propertyPath === 'config.repeatCount.min' ||
                propertyPath === 'config.repeatCount.max'
            ) {
                if (!node.config) node.config = {};
                const prev = node.config.repeatCount;
                const prop = propertyPath.split('.').pop();

                if (prop === 'type') {
                    const nextType = (newValue || '').toString();
                    if (nextType === '—') {
                        // No repeat: completely remove repeatCount structure
                        delete node.config.repeatCount;
                        // Update JSON and re-render
                        isProgrammaticUpdate = true;
                        jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                        renderWorkoutTable(currentWorkoutData);
                        setTimeout(() => {
                            isProgrammaticUpdate = false;
                        }, 100);
                        showSuccessMessage('Removed repeat count');
                        return;
                    }
                }

                // Ensure repeatCount is an object before editing subfields
                if (typeof prev !== 'object' || prev === null) {
                    const numeric = typeof prev === 'number' ? prev : 1;
                    node.config.repeatCount = { type: 'fixed', count: Math.max(1, Number.isFinite(numeric) ? numeric : 1) };
                }

                const rc = node.config.repeatCount;

                if (prop === 'type') {
                    const nextType = (newValue || '').toString();
                    if (nextType === 'fixed') {
                        const fallback = Number.isFinite(rc.count) ? rc.count : (Number.isFinite(rc.min) ? rc.min : 1);
                        rc.type = 'fixed';
                        rc.count = Math.max(1, parseInt(fallback || 1, 10));
                        delete rc.min;
                        delete rc.max;
                    } else if (nextType === 'random') {
                        // Prefer existing min/max if present; else derive from count; else default 1..3
                        let minVal = Number.isFinite(rc.min) ? rc.min : 0;
                        let maxVal = Number.isFinite(rc.max) ? rc.max : (Number.isFinite(rc.count) ? Math.max(1, rc.count) : 3);
                        minVal = Math.max(0, parseInt(minVal, 10) || 0);
                        maxVal = Math.max(minVal, parseInt(maxVal, 10) || minVal);
                        rc.type = 'random';
                        rc.min = minVal;
                        rc.max = maxVal;
                        delete rc.count;
                    }
                } else if (prop === 'count') {
                    // Editing count implies fixed type
                    const numValue = parseInt(newValue, 10);
                    if (!Number.isFinite(numValue) || numValue < 1) {
                        showError(`Invalid number: ${newValue}`);
                        return;
                    }
                    rc.type = 'fixed';
                    rc.count = numValue;
                    delete rc.min;
                    delete rc.max;
                } else if (prop === 'min' || prop === 'max') {
                    // Editing random bounds implies random type
                    const numValue = parseInt(newValue, 10);
                    if (!Number.isFinite(numValue) || numValue < 0) {
                        showError(`Invalid number: ${newValue}`);
                        return;
                    }
                    rc.type = 'random';
                    if (prop === 'min') rc.min = numValue; else rc.max = numValue;
                    // Normalize so that min <= max
                    const minVal = Math.max(0, parseInt(rc.min ?? 0, 10));
                    const maxVal = Math.max(Math.max(minVal, 1), parseInt(rc.max ?? Math.max(minVal, 1), 10));
                    if (maxVal < minVal) {
                        // If user set min above max, bump max up to min
                        rc.min = minVal;
                        rc.max = minVal;
                    } else {
                        rc.min = minVal;
                        rc.max = maxVal;
                    }
                    delete rc.count;
                }

                // Track the updated row and cell for green highlighting
                let trackingNodeId;
                if (node.type === 'Workout') {
                    trackingNodeId = 'row-0';
                } else {
                    trackingNodeId = node.id || node.nodeId;
                }
                updatedRows.add(trackingNodeId);
                const propertyName = extractPropertyNameForCell(propertyPath);
                const cellKey = `${trackingNodeId}-${propertyName}`;
                updatedCells.set(cellKey, true);

                const nodeIdentifier = node.id || node.name || node.type;
                const propertyKey = `${node.type}-${nodeIdentifier}-${propertyPath}`;
                updatedProperties.set(propertyKey, true);

                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    isProgrammaticUpdate = false;
                }, 100);

                const displayVal = prop === 'type' ? rc.type : (prop === 'count' ? rc.count : `${rc.min}..${rc.max}`);
                showSuccessMessage(`Updated repeatCount ${prop} to ${displayVal}`);
                return;
            }
            
            // Parse the property path (e.g., "config.interval" or "name")
            const pathParts = propertyPath.split('.');
            let target = node;
            
            // Navigate to the parent object
            for (let i = 0; i < pathParts.length - 1; i++) {
                if (!target[pathParts[i]]) {
                    target[pathParts[i]] = {};
                }
                target = target[pathParts[i]];
            }
            
            const finalProperty = pathParts[pathParts.length - 1];
            
            // Convert value based on expected type
            let convertedValue = newValue;
            if (finalProperty === 'interval') {
                // Handle interval differently for Messages vs Shots/Workouts
                if (node.type === 'Message') {
                    // Messages use MM:SS string format
                    if (/^\d{1,2}:\d{2}$/.test(newValue)) {
                        convertedValue = newValue; // Keep as string
                    } else {
                        // Try to convert numeric seconds to MM:SS format
                        const seconds = parseFloat(newValue);
                        if (isNaN(seconds) || seconds < 0 || seconds > 300) {
                            showError(`Invalid interval for Message. Use MM:SS format (e.g., "01:00", "00:30") or seconds (0-300).`);
                            return;
                        }
                        const minutes = Math.floor(seconds / 60);
                        const remainingSeconds = Math.floor(seconds % 60);
                        convertedValue = `${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
                    }
                } else {
                    // Shots and Workouts use numeric seconds
                    convertedValue = parseFloat(newValue);
                    if (isNaN(convertedValue) || convertedValue < 0) {
                        showError(`Invalid number: ${newValue}`);
                        return;
                    }
                }
            } else if (finalProperty === 'speechRate' || 
                finalProperty === 'shotAnnouncementLeadTime' || finalProperty === 'repeatCount') {
                convertedValue = parseFloat(newValue);
                if (isNaN(convertedValue)) {
                    showError(`Invalid number: ${newValue}`);
                    return;
                }
            } else if (finalProperty === 'autoVoiceSplitStep' || finalProperty === 'countdown' || 
                       finalProperty === 'skipAtEndOfWorkout') {
                convertedValue = newValue.toLowerCase() === 'true';
            }
            
            // Handle type changes with structural adjustments
            if (propertyPath === 'type') {
                const oldType = node.type;
                const newType = convertedValue;
                node.type = newType;
                // Update row background color class based on new type
                const rowEl = document.getElementById(node.id || node.nodeId || '');
                if (rowEl) {
                    rowEl.classList.remove('bg-red-100','bg-purple-100','bg-blue-100');
                    if (newType === 'Workout') rowEl.classList.add('bg-red-100');
                    if (newType === 'Pattern') rowEl.classList.add('bg-purple-100');
                    if (newType === 'Shot' || newType === 'Message') rowEl.classList.add('bg-blue-100');
                }
                // If changing to Pattern, ensure it has entries array and adopt following shot/message siblings
                if (newType === 'Pattern') {
                    if (!Array.isArray(node.entries)) node.entries = [];
                    if (!node.positionType) node.positionType = 'normal';

                    const parentNode = getParentNode(node);
                    if (parentNode && Array.isArray(parentNode.entries)) {
                        const siblings = parentNode.entries;
                        const idx = siblings.indexOf(node);
                        if (idx !== -1) {
                            const toMove = [];
                            // Move contiguous Shot/Message siblings after this node until next Pattern or end
                            for (let i = idx + 1; i < siblings.length; i++) {
                                const sib = siblings[i];
                                if (!sib || sib.type === 'Pattern') break;
                                toMove.push(sib);
                            }
                            if (toMove.length > 0) {
                                // Remove them from parent's entries
                                siblings.splice(idx + 1, toMove.length);
                                // Append as children of the new Pattern
                                node.entries.push(...toMove);
                            }

                            // Promote this node to top-level patterns under Workout
                            const workoutRoot = currentWorkoutData;
                            // Remove the node from its parent's entries
                            siblings.splice(idx, 1);
                            if (!Array.isArray(workoutRoot.patterns)) workoutRoot.patterns = [];
                            const parentPatternIndex = workoutRoot.patterns.indexOf(parentNode);
                            const insertIndex = parentPatternIndex >= 0 ? parentPatternIndex + 1 : workoutRoot.patterns.length;
                            workoutRoot.patterns.splice(insertIndex, 0, node);
                        }
                    }
                }
                // If changing a Pattern into Shot/Message, demote to a Pattern's entries
                if (oldType === 'Pattern' && (newType === 'Shot' || newType === 'Message')) {
                    if (!node.positionType) node.positionType = 'normal';
                    const parentNode = getParentNode(node);
                    const workoutRoot = currentWorkoutData;
                    let hostPattern = null;
                    let insertIndexInHost = null;

                    // If current parent is a Pattern, keep under that parent
                    if (parentNode && parentNode.type === 'Pattern' && Array.isArray(parentNode.entries)) {
                        hostPattern = parentNode;
                        // Replace this node in parent's entries at same position
                        const idx = parentNode.entries.indexOf(node);
                        if (idx !== -1) {
                            insertIndexInHost = idx; // maintain position
                            parentNode.entries.splice(idx, 1); // remove temporarily; will be reinserted below
                        }
                    } else if (parentNode && parentNode.type === 'Workout' && Array.isArray(parentNode.patterns)) {
                        // Need to find neighbor pattern to host this shot/message
                        const patterns = parentNode.patterns;
                        const pIdx = patterns.indexOf(node);
                        // Prefer previous pattern, else next pattern
                        if (pIdx > 0) {
                            hostPattern = patterns[pIdx - 1];
                        } else if (pIdx >= 0 && pIdx < patterns.length - 1) {
                            hostPattern = patterns[pIdx + 1];
                        }
                        // If none found, create a minimal host pattern and insert before this node
                        if (!hostPattern) {
                            hostPattern = {
                                type: 'Pattern',
                                id: null,
                                name: 'New Pattern',
                                positionType: 'normal',
                                config: { iterationType: 'in-order', limits: { type: 'all-shots', value: null } },
                                entries: []
                            };
                            const insertAt = Math.max(0, pIdx);
                            patterns.splice(insertAt, 0, hostPattern);
                        }
                        // Remove demoted node from workout patterns
                        if (pIdx !== -1) patterns.splice(pIdx, 1);
                        // Append at end by default
                        insertIndexInHost = hostPattern.entries.length;
                    }

                    if (hostPattern) {
                        if (!Array.isArray(hostPattern.entries)) hostPattern.entries = [];
                        // Preserve children: append them after the demoted node
                        const preservedChildren = Array.isArray(node.entries) ? [...node.entries] : [];
                        // Clear entries on the demoted node
                        delete node.entries;
                        // Insert demoted node into host
                        if (insertIndexInHost === null || insertIndexInHost === undefined) {
                            hostPattern.entries.push(node);
                        } else {
                            hostPattern.entries.splice(insertIndexInHost, 0, node);
                        }
                        // Append preserved children after the demoted node
                        if (preservedChildren.length > 0) {
                            const afterIndex = (insertIndexInHost === null || insertIndexInHost === undefined)
                                ? hostPattern.entries.length
                                : insertIndexInHost + 1;
                            hostPattern.entries.splice(afterIndex, 0, ...preservedChildren);
                        }
                    }
                }
            } else {
                target[finalProperty] = convertedValue;
            }
            

            

            
            // Recompute change tracking so reverted values are not highlighted
            if (originalWorkoutData) {
                updatedRows.clear();
                updatedCells.clear();
                updatedProperties.clear();
                const currentFiltered = filterNodeIds(currentWorkoutData);
                const changes = compareWorkoutData(originalWorkoutData, currentFiltered);
                changes.forEach(change => {
                    const changeNode = findNodeByPath(currentFiltered, change.path);
                    if (changeNode) {
                        const rowId = changeNode.id || (changeNode.type === 'Workout' ? 'row-0' : null);
                        if (rowId) {
                            updatedRows.add(rowId);
                            const propName = extractPropertyNameForCell(change.path);
                            const changeCellKey = `${rowId}-${propName}`;
                            updatedCells.set(changeCellKey, true);
                            const changeNodeIdentifier = changeNode.id || changeNode.name || changeNode.type;
                            const changePropertyKey = `${changeNode.type}-${changeNodeIdentifier}-${change.path}`;
                            updatedProperties.set(changePropertyKey, true);
                        }
                    }
                });
            } else {
                // Fallback: track manually when no baseline exists
                let trackingNodeId;
                if (node.type === 'Workout') {
                    trackingNodeId = 'row-0';
                } else {
                    trackingNodeId = node.id || node.nodeId;
                }
                updatedRows.add(trackingNodeId);
                const propertyName = extractPropertyNameForCell(propertyPath);
                const cellKey = `${trackingNodeId}-${propertyName}`;
                updatedCells.set(cellKey, true);
                const nodeIdentifier = node.id || node.name || node.type;
                const propertyKey = `${node.type}-${nodeIdentifier}-${propertyPath}`;
                updatedProperties.set(propertyKey, true);
                if (propertyPath === 'config.intervalOffset.min' || propertyPath === 'config.intervalOffset.max') {
                    const otherPropertyPath = propertyPath === 'config.intervalOffset.min' ? 'config.intervalOffset.max' : 'config.intervalOffset.min';
                    const otherPropertyKey = `${node.type}-${nodeIdentifier}-${otherPropertyPath}`;
                    updatedProperties.set(otherPropertyKey, true);
                }
            }
            
            // Update the JSON input and re-render the table
            isProgrammaticUpdate = true;
            jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
            
            // Re-render the table to update inheritance display
            renderWorkoutTable(currentWorkoutData);
            
            // Reset the flag after a short delay to ensure handleJsonInputChange doesn't trigger
            setTimeout(() => {
                isProgrammaticUpdate = false;
            }, 100);
            
            // Show success feedback
            const wasInherited = !hasProperty(node, propertyPath);
            
            // Format numeric values to 2 decimal places for display
            let displayValue = newValue;
            if (typeof convertedValue === 'number' && (finalProperty === 'interval' || finalProperty === 'shotAnnouncementLeadTime' || finalProperty === 'speechRate')) {
                displayValue = convertedValue.toFixed(2);
            }
            
            const message = wasInherited 
                ? `Made ${propertyPath} explicit: ${displayValue} (was inherited: ${inheritedValue})`
                : `Updated ${propertyPath} to ${displayValue}`;
            showSuccessMessage(message);
        }
        
        function getInheritedValue(node, propertyPath) {
            // Get the inherited value by looking up the hierarchy
            const parentNode = getParentNode(node);
            if (!parentNode) {
                // Return default values for root level (Workout)
                const defaults = {
                    'config.voice': 'Default',
                    'config.speechRate': 1.0,
                    'config.interval': 5.0,
                    'config.intervalOffsetType': 'fixed',
                    'config.intervalOffset': { min: 0.0, max: 0.0 },
                    'config.autoVoiceSplitStep': true,
                    'config.shotAnnouncementLeadTime': 2.5,
                    'config.splitStepSpeed': 'auto-scale',
                    'config.iterationType': 'in-order',
                    'config.limits': { type: 'all-shots', value: null },
                    'config.countdown': false,
                    'config.skipAtEndOfWorkout': false,
                    'config.intervalType': 'fixed'
                };
                return defaults[propertyPath];
            }
            
            // Calculate the effective config for the parent node
            const parentEffectiveConfig = calculateEffectiveConfig(parentNode);
            
            // Extract the property from the effective config
            const pathParts = propertyPath.split('.');
            let target = parentEffectiveConfig;
            
            for (const part of pathParts) {
                if (target && typeof target === 'object' && target.hasOwnProperty(part)) {
                    target = target[part];
                } else {
                    return undefined;
                }
            }
            
            return target;
        }
        
        function calculateEffectiveConfig(node) {
            // Calculate effective config by merging with parent config
            const parentNode = getParentNode(node);
            let parentConfig = {};
            
            if (parentNode) {
                parentConfig = calculateEffectiveConfig(parentNode);
            } else {
                // Root level defaults
                parentConfig = {
                    voice: 'Default',
                    speechRate: 1.0,
                    interval: 5.0,
                    intervalOffsetType: 'fixed',
                    intervalOffset: { min: 0.0, max: 0.0 },
                    autoVoiceSplitStep: true,
                    shotAnnouncementLeadTime: 2.5,
                    splitStepSpeed: 'auto-scale',
                    iterationType: 'in-order',
                    limits: { type: 'all-shots', value: null },
                    countdown: false,
                    skipAtEndOfWorkout: false,
                    intervalType: 'fixed'
                };
            }
            
            // Deep merge with current node's config
            const currentConfig = node.config || {};
            const mergedConfig = { ...parentConfig };
            
            // Handle nested objects properly
            for (const [key, value] of Object.entries(currentConfig)) {
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    // Deep merge for objects like intervalOffset and limits
                    mergedConfig[key] = { ...(parentConfig[key] || {}), ...value };
                } else {
                    mergedConfig[key] = value;
                }
            }
            
            return mergedConfig;
        }
        
        function extractPropertyNameForCell(propertyPath) {
            let propertyName = propertyPath.split('.').pop();
            
            // Handle special cases for nested properties
            if (propertyPath.includes('config.')) {
                const pathParts = propertyPath.split('.');
                const configIndex = pathParts.indexOf('config');
                if (configIndex !== -1 && configIndex < pathParts.length - 1) {
                    // For nested config properties, use the path after config (matching createCell logic)
                    const afterConfig = pathParts.slice(configIndex + 1);
                    propertyName = afterConfig.join('.');
                }
            }
            
            return propertyName;
        }
        
        function filterNodeIds(obj) {
            if (obj === null || typeof obj !== 'object') {
                return obj;
            }
            
            if (Array.isArray(obj)) {
                return obj.map(item => filterNodeIds(item));
            }
            
            const filtered = {};
            for (const [key, value] of Object.entries(obj)) {
                if (key !== 'nodeId') {
                    filtered[key] = filterNodeIds(value);
                }
            }
            return filtered;
        }
        
        function preserveNodeIds(newData, existingData) {
            if (newData === null || typeof newData !== 'object') {
                return newData;
            }
            
            if (Array.isArray(newData)) {
                return newData.map((item, index) => {
                    const existingItem = existingData && Array.isArray(existingData) && existingData[index];
                    return preserveNodeIds(item, existingItem);
                });
            }
            
            const preserved = { ...newData };
            if (existingData && typeof existingData === 'object' && existingData.nodeId) {
                preserved.nodeId = existingData.nodeId;
            }
            
            // Recursively preserve nodeIds in nested objects
            for (const [key, value] of Object.entries(preserved)) {
                if (typeof value === 'object' && value !== null) {
                    const existingValue = existingData && existingData[key];
                    preserved[key] = preserveNodeIds(value, existingValue);
                }
            }
            
            return preserved;
        }
        
        function calculateEffectiveConfigForNode(node, parentConfig) {
            // Respect json-spec.md inheritance rules
            const currentConfig = node.config || {};
            const inheritableKeys = ['voice','speechRate','interval','intervalOffsetType','intervalOffset','autoVoiceSplitStep','shotAnnouncementLeadTime','splitStepSpeed'];
            const nonInheritableDefaults = {
                // Pattern-only
                iterationType: 'in-order',
                limits: { type: 'all-shots', value: null },
                // Pattern/Shot
                repeatCount: 1,
                // Message-only
                intervalType: 'fixed',
                countdown: false,
                skipAtEndOfWorkout: false,
            };

            // Start with only inheritable keys from parent
            const mergedConfig = {};
            inheritableKeys.forEach(key => {
                if (parentConfig && parentConfig[key] !== undefined) {
                    // Deep copy objects like intervalOffset
                    mergedConfig[key] = typeof parentConfig[key] === 'object' && parentConfig[key] !== null
                        ? { ...parentConfig[key] }
                        : parentConfig[key];
                }
            });

            // Apply current config values (override inheritable, set non-inheritable when present)
            for (const [key, value] of Object.entries(currentConfig)) {
                if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                    mergedConfig[key] = { ...(mergedConfig[key] || {}), ...value };
                } else {
                    mergedConfig[key] = value;
                }
            }

            // Enforce non-inheritance per node type
            if (node.type === 'Pattern') {
                mergedConfig.iterationType = currentConfig.iterationType ?? nonInheritableDefaults.iterationType;
                mergedConfig.limits = currentConfig.limits ? { ...currentConfig.limits } : { ...nonInheritableDefaults.limits };
                mergedConfig.repeatCount = currentConfig.repeatCount ?? nonInheritableDefaults.repeatCount;
            } else if (node.type === 'Shot') {
                mergedConfig.repeatCount = currentConfig.repeatCount ?? nonInheritableDefaults.repeatCount;
            } else if (node.type === 'Message') {
                mergedConfig.intervalType = currentConfig.intervalType ?? nonInheritableDefaults.intervalType;
                mergedConfig.countdown = currentConfig.countdown ?? nonInheritableDefaults.countdown;
                mergedConfig.skipAtEndOfWorkout = currentConfig.skipAtEndOfWorkout ?? nonInheritableDefaults.skipAtEndOfWorkout;
            } else if (node.type === 'Workout') {
                // Workout honors its own iterationType/limits if present; otherwise keep defaults set in rootDefaults
                mergedConfig.iterationType = currentConfig.iterationType ?? (parentConfig?.iterationType ?? nonInheritableDefaults.iterationType);
                mergedConfig.limits = currentConfig.limits ? { ...currentConfig.limits } : (parentConfig?.limits ? { ...parentConfig.limits } : { ...nonInheritableDefaults.limits });
            }

            return mergedConfig;
        }
        
        function getCurrentValue(node, propertyPath) {
            const pathParts = propertyPath.split('.');
            let target = node;
            
            for (const part of pathParts) {
                if (target && typeof target === 'object' && target.hasOwnProperty(part)) {
                    target = target[part];
                } else {
                    return undefined;
                }
            }
            
            return target;
        }
        
        function hasProperty(node, propertyPath) {
            const pathParts = propertyPath.split('.');
            let target = node;
            
            // Navigate to the parent object
            for (let i = 0; i < pathParts.length - 1; i++) {
                if (!target[pathParts[i]]) {
                    return false; // Property doesn't exist
                }
                target = target[pathParts[i]];
            }
            
            const finalProperty = pathParts[pathParts.length - 1];
            return target.hasOwnProperty(finalProperty);
        }
        
        function removeProperty(node, propertyPath) {
            const pathParts = propertyPath.split('.');
            let target = node;
            
            // Navigate to the parent object
            for (let i = 0; i < pathParts.length - 1; i++) {
                if (!target[pathParts[i]]) {
                    return; // Property doesn't exist
                }
                target = target[pathParts[i]];
            }
            
            const finalProperty = pathParts[pathParts.length - 1];
            delete target[finalProperty];
            
            // Clean up empty objects
            if (pathParts.length > 1 && Object.keys(target).length === 0) {
                const parentPath = pathParts.slice(0, -1);
                let parentTarget = node;
                for (let i = 0; i < parentPath.length - 1; i++) {
                    parentTarget = parentTarget[parentPath[i]];
                }
                delete parentTarget[parentPath[parentPath.length - 1]];
            }
        }
        
        function getParentNode(node) {
            // Find the parent node by searching through the tree
            return findParentNode(currentWorkoutData, node);
        }
        
        function findParentNode(root, targetNode) {
            if (!root || typeof root !== 'object') return null;
            
            const children = root.patterns || root.entries;
            if (Array.isArray(children)) {
                for (const child of children) {
                    if (child === targetNode) {
                        return root;
                    }
                    const result = findParentNode(child, targetNode);
                    if (result) return result;
                }
            }
            return null;
        }
        
        function findNodeById(node, targetId) {
            // Special case for workout element (root element) which doesn't have an id
            if (targetId === 'row-0' && node.type === 'Workout') {
                return node;
            }
            
            if (node.id === targetId || node.nodeId === targetId) return node;
            
            const children = node.patterns || node.entries;
            if (Array.isArray(children)) {
                for (const child of children) {
                    const result = findNodeById(child, targetId);
                    if (result) return result;
                }
            }
            return null;
        }
        
        function findNodeByTypeAndIdentifier(node, targetType, targetIdentifier) {
            // Special case for workout element
            if (targetType === 'Workout' && node.type === 'Workout') {
                return node;
            }
            
            // Check if this node matches
            if (node.type === targetType) {
                const nodeIdentifier = node.id || node.name || node.type;
                if (nodeIdentifier === targetIdentifier) {
                    return node;
                }
            }
            
            // Search children
            const children = node.patterns || node.entries;
            if (Array.isArray(children)) {
                for (const child of children) {
                    const result = findNodeByTypeAndIdentifier(child, targetType, targetIdentifier);
                    if (result) return result;
                }
            }
            return null;
        }
        
        function compareWorkoutData(original, current, path = '') {
            // Compare two workout objects and return a list of changed properties
            const changes = [];
            
            function compareObjects(orig, curr, currentPath) {
                if (!orig || !curr) {
                    if (orig !== curr) {
                        console.log(`compareWorkoutData: Found change at ${currentPath}: ${orig} -> ${curr}`);
                        changes.push({ path: currentPath, original: orig, current: curr });
                    }
                    return;
                }
                
                if (typeof orig !== typeof curr) {
                    console.log(`compareWorkoutData: Type change at ${currentPath}: ${typeof orig} -> ${typeof curr}`);
                    changes.push({ path: currentPath, original: orig, current: curr });
                    return;
                }
                
                if (typeof orig !== 'object' || orig === null) {
                    if (orig !== curr) {
                        console.log(`compareWorkoutData: Value change at ${currentPath}: ${orig} -> ${curr}`);
                        changes.push({ path: currentPath, original: orig, current: curr });
                    }
                    return;
                }
                
                if (Array.isArray(orig) !== Array.isArray(curr)) {
                    console.log(`compareWorkoutData: Array type change at ${currentPath}`);
                    changes.push({ path: currentPath, original: orig, current: curr });
                    return;
                }
                
                if (Array.isArray(orig)) {
                    // For arrays, compare each element
                    const maxLength = Math.max(orig.length, curr.length);
                    for (let i = 0; i < maxLength; i++) {
                        const origItem = orig[i];
                        const currItem = curr[i];
                        const itemPath = `${currentPath}[${i}]`;
                        compareObjects(origItem, currItem, itemPath);
                    }
                } else {
                    // For objects, compare each property
                    const allKeys = new Set([...Object.keys(orig), ...Object.keys(curr)]);
                    for (const key of allKeys) {
                        const origValue = orig[key];
                        const currValue = curr[key];
                        const propPath = currentPath ? `${currentPath}.${key}` : key;
                        compareObjects(origValue, currValue, propPath);
                    }
                }
            }
            
            compareObjects(original, current, path);
            return changes;
        }
        
        function findNodeContainingPath(workoutData, path) {
            // Find the node that contains a specific property path
            function searchNode(node, currentPath = '') {
                // Check if this node contains the path
                const nodePath = currentPath ? `${currentPath}.${node.type}` : node.type;
                
                // Check direct properties
                for (const [key, value] of Object.entries(node)) {
                    if (key === 'config' || key === 'patterns' || key === 'entries') continue;
                    
                    const propPath = `${nodePath}.${key}`;
                    if (path.startsWith(propPath)) {
                        return node;
                    }
                }
                
                // Check config properties
                if (node.config) {
                    for (const [key, value] of Object.entries(node.config)) {
                        const propPath = `${nodePath}.config.${key}`;
                        if (path.startsWith(propPath)) {
                            return node;
                        }
                    }
                }
                
                // Recursively search children
                const children = node.patterns || node.entries;
                if (Array.isArray(children)) {
                    for (let i = 0; i < children.length; i++) {
                        const child = children[i];
                        const childPath = `${nodePath}.${children === node.patterns ? 'patterns' : 'entries'}[${i}]`;
                        const result = searchNode(child, childPath);
                        if (result) return result;
                    }
                }
                
                return null;
            }
            
            return searchNode(workoutData);
        }
        
        function findNodeByPath(workoutData, path) {
            // Parse the path to find the exact node
            const pathParts = path.split('.');
            let current = workoutData;
            let node = workoutData;
            
            for (let i = 0; i < pathParts.length; i++) {
                const part = pathParts[i];
                
                // Handle array indexing like patterns[0]
                if (part.includes('[') && part.includes(']')) {
                    const arrayName = part.substring(0, part.indexOf('['));
                    const indexStr = part.substring(part.indexOf('[') + 1, part.indexOf(']'));
                    const index = parseInt(indexStr);
                    
                    if (current[arrayName] && Array.isArray(current[arrayName]) && current[arrayName][index]) {
                        current = current[arrayName][index];
                        node = current; // Update the node reference
                    } else {
                        return null;
                    }
                } else {
                    if (current && current.hasOwnProperty(part)) {
                        current = current[part];
                        // Only update node reference for object nodes, not for primitive values
                        if (typeof current === 'object' && current !== null && (current.type || current.id)) {
                            node = current;
                        }
                    } else {
                        return null;
                    }
                }
            }
            
            return node;
        }
        
        function formatCellValue(value) {
            if (value === null || value === undefined || value === '') return '—';
            if (typeof value === 'number') return value.toFixed(1);
            return value.toString();
        }
        
        function showSuccessMessage(message) {
            // Create a temporary success message
            const successDiv = document.createElement('div');
            successDiv.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-2 rounded-lg shadow-lg z-50';
            successDiv.textContent = message;
            document.body.appendChild(successDiv);
            
            setTimeout(() => {
                successDiv.remove();
            }, 2000);
        }

        function updateNavIndex(currentIndex, totalCount) {
            if (totalCount === 0) {
                navIndex.textContent = '-';
            } else {
                navIndex.textContent = `${currentIndex + 1}/${totalCount}`;
            }
        }
        
        function updateGreenNavIndex(currentIndex, totalCount) {
            if (totalCount === 0) {
                greenNavIndex.textContent = '-';
            } else {
                greenNavIndex.textContent = `${currentIndex + 1}/${totalCount}`;
            }
        }

        function navigateToNextRedRow() {
            const redRows = Array.from(document.querySelectorAll('tr.select-row-highlight'));
            if (redRows.length === 0) {
                updateNavIndex(-1, 0);
                return;
            }
            
            const currentFocusedRow = document.querySelector('tr.select-row-highlight.focused');
            let nextIndex = 0;
            
            if (currentFocusedRow) {
                const currentIndex = redRows.indexOf(currentFocusedRow);
                nextIndex = (currentIndex + 1) % redRows.length;
                currentFocusedRow.classList.remove('focused');
            }
            
            const nextRow = redRows[nextIndex];
            nextRow.classList.add('focused');
            nextRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            updateNavIndex(nextIndex, redRows.length);
        }

        function navigateToPreviousRedRow() {
            const redRows = Array.from(document.querySelectorAll('tr.select-row-highlight'));
            if (redRows.length === 0) {
                updateNavIndex(-1, 0);
                return;
            }
            
            const currentFocusedRow = document.querySelector('tr.select-row-highlight.focused');
            let prevIndex = redRows.length - 1;
            
            if (currentFocusedRow) {
                const currentIndex = redRows.indexOf(currentFocusedRow);
                prevIndex = currentIndex === 0 ? redRows.length - 1 : currentIndex - 1;
                currentFocusedRow.classList.remove('focused');
            }
            
            const prevRow = redRows[prevIndex];
            prevRow.classList.add('focused');
            prevRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            updateNavIndex(prevIndex, redRows.length);
        }
        
        function navigateToNextGreenCell() {
            const greenCells = Array.from(document.querySelectorAll('.update-cell-highlight'));
            if (greenCells.length === 0) {
                updateGreenNavIndex(-1, 0);
                return;
            }
            
            const currentFocusedCell = document.querySelector('.update-cell-highlight.focused');
            let nextIndex = 0;
            
            if (currentFocusedCell) {
                const currentIndex = greenCells.indexOf(currentFocusedCell);
                nextIndex = (currentIndex + 1) % greenCells.length;
                currentFocusedCell.classList.remove('focused');
            }
            
            const nextCell = greenCells[nextIndex];
            nextCell.classList.add('focused');
            nextCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            updateGreenNavIndex(nextIndex, greenCells.length);
        }
        
        function navigateToPreviousGreenCell() {
            const greenCells = Array.from(document.querySelectorAll('.update-cell-highlight'));
            if (greenCells.length === 0) {
                updateGreenNavIndex(-1, 0);
                return;
            }
            
            const currentFocusedCell = document.querySelector('.update-cell-highlight.focused');
            let prevIndex = greenCells.length - 1;
            
            if (currentFocusedCell) {
                const currentIndex = greenCells.indexOf(currentFocusedCell);
                prevIndex = currentIndex === 0 ? greenCells.length - 1 : currentIndex - 1;
                currentFocusedCell.classList.remove('focused');
            }
            
            const prevCell = greenCells[prevIndex];
            prevCell.classList.add('focused');
            prevCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            updateGreenNavIndex(prevIndex, greenCells.length);
        }

        document.addEventListener('DOMContentLoaded', handleDisplay);

        function enterCopyMode() {
            if (copyModeActive) return;
            // Turn off other modes
            if (cutModeActive) exitCutMode();
            if (pasteModeActive) exitPasteMode();
            copyModeActive = true;
            copiedRowData = null;
            // Button visual
            if (copyModeButton) {
                copyModeButton.classList.remove('bg-blue-600');
                copyModeButton.classList.add('bg-blue-800', 'ring-2', 'ring-offset-2', 'ring-blue-300');
                copyModeButton.setAttribute('aria-pressed', 'true');
                copyModeButton.title = 'Copy (active): click a row to copy, or click again to cancel';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.add('copy-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handleCopyRowClick, true);
                // Live hover preview of selection box in copy mode
                row.addEventListener('mouseenter', () => {
                    if (copyModeActive) row.classList.add('copy-row-hover');
                });
                row.addEventListener('mouseleave', () => {
                    row.classList.remove('copy-row-hover');
                });
            });
            showSuccessMessage('Copy mode: Click a row to copy');
        }

        function exitCopyMode() {
            copyModeActive = false;
            if (copyModeButton) {
                copyModeButton.classList.add('bg-blue-600');
                copyModeButton.classList.remove('bg-blue-800', 'ring-2', 'ring-offset-2', 'ring-blue-300');
                copyModeButton.setAttribute('aria-pressed', 'false');
                copyModeButton.title = 'Copy: select a row to copy';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.remove('copy-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.removeEventListener('click', handleCopyRowClick, true);
                row.classList.remove('copy-row-highlight');
                row.classList.remove('copy-row-hover');
            });
        }

        function enterPasteMode() {
            if (pasteModeActive) return;
            if (!copiedRowData) { showError('No row copied yet'); return; }
            // Turn off other modes
            if (cutModeActive) exitCutMode();
            if (addModeActive) exitAddMode();
            if (copyModeActive) exitCopyMode();
            pasteModeActive = true;
            if (pasteModeButton) {
                pasteModeButton.classList.remove('bg-green-600');
                pasteModeButton.classList.add('bg-green-800', 'ring-2', 'ring-offset-2', 'ring-green-300');
                pasteModeButton.setAttribute('aria-pressed', 'true');
                pasteModeButton.title = 'Paste (active): click a row to insert after, or click again to cancel';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.add('paste-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handlePasteRowClick, true);
                // Live hover preview of insertion line in paste mode
                row.addEventListener('mouseenter', () => {
                    if (pasteModeActive) row.classList.add('paste-row-hover');
                });
                row.addEventListener('mouseleave', () => {
                    row.classList.remove('paste-row-hover');
                });
            });
            showSuccessMessage('Paste mode: click a row to insert after it');
        }

        function exitPasteMode() {
            pasteModeActive = false;
            if (pasteModeButton) {
                pasteModeButton.classList.add('bg-green-600');
                pasteModeButton.classList.remove('bg-green-800', 'ring-2', 'ring-offset-2', 'ring-green-300');
                pasteModeButton.setAttribute('aria-pressed', 'false');
                pasteModeButton.title = 'Paste: select where to insert the copied row';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.remove('paste-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.removeEventListener('click', handlePasteRowClick, true);
                row.classList.remove('paste-insert-highlight');
                row.classList.remove('paste-row-hover');
            });
        }

        function handleCopyRowClick(event) {
            if (!copyModeActive) return;
            event.preventDefault();
            event.stopPropagation();
            const row = event.currentTarget;
            // Reuse the same selection box used by cut mode
            document.querySelectorAll('tr.copy-row-highlight, tr.cut-row-highlight').forEach(el => el.classList.remove('copy-row-highlight', 'cut-row-highlight'));
            row.classList.add('copy-row-highlight');
            const nodeId = row.id;
            const node = findNodeById(currentWorkoutData, nodeId);
            if (!node) { showError('Could not find node data for selected row'); return; }
            if (node.type === 'Workout') { showError('Cannot copy the workout node'); return; }
            // Deep clone and assign new id for paste
            copiedRowData = JSON.parse(JSON.stringify(node));
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substring(2, 8);
            copiedRowData.id = `${(copiedRowData.type || 'row').toLowerCase()}_${timestamp}_${randomSuffix}`;
            delete copiedRowData.nodeId;
            showSuccessMessage(`Copied ${node.type}: ${node.name || node.id}`);
        }

        function handlePasteRowClick(event) {
            if (!pasteModeActive || !copiedRowData) return;
            event.preventDefault();
            event.stopPropagation();
            const targetRow = event.currentTarget;
            // Only highlight the bottom of the target row
            document.querySelectorAll('tr.paste-insert-highlight').forEach(el => el.classList.remove('paste-insert-highlight'));
            targetRow.classList.add('paste-insert-highlight');
            const targetNodeId = targetRow.id;
            const targetNode = findNodeById(currentWorkoutData, targetNodeId);
            if (!targetNode) { showError('Could not find target node for insertion'); return; }
            // Determine parent and insertion point
            let parentNode = findParentNode(currentWorkoutData, targetNode);
            if (!parentNode) { showError('Could not find parent node for insertion'); return; }
            let childrenArray = parentNode.patterns || parentNode.entries;
            if (!Array.isArray(childrenArray)) { showError('Parent node does not have a children array'); return; }
            const targetIndex = childrenArray.findIndex(child => child === targetNode);
            if (targetIndex === -1) { showError('Could not find target node in parent array'); return; }
            // Restrict pattern pasting to workout level only
            if (copiedRowData.type === 'Pattern') {
                // Find workout ancestor
                let workoutNode = targetNode;
                while (workoutNode && workoutNode.type !== 'Workout') {
                    workoutNode = findParentNode(currentWorkoutData, workoutNode);
                }
                if (!workoutNode || workoutNode.type !== 'Workout') { showError('Could not find workout node for pattern insertion'); return; }
                const patternsArray = workoutNode.patterns || [];
                // Insert after the current pattern containing target or at end
                let currentPattern = targetNode.type === 'Pattern' ? targetNode : targetNode;
                while (currentPattern && currentPattern.type !== 'Pattern') {
                    currentPattern = findParentNode(currentWorkoutData, currentPattern);
                }
                const nodeToInsert = JSON.parse(JSON.stringify(copiedRowData));
                regenerateIdsForSubtree(nodeToInsert);
                const insertedRootId = nodeToInsert.id;
                if (currentPattern && currentPattern.type === 'Pattern') {
                    const patternIndex = patternsArray.findIndex(p => p === currentPattern);
                    if (patternIndex !== -1) {
                        patternsArray.splice(patternIndex + 1, 0, nodeToInsert);
                    } else {
                        patternsArray.push(nodeToInsert);
                    }
                } else {
                    patternsArray.push(nodeToInsert);
                }
                // Mark inserted pattern row as changed (green highlight)
                updatedRows.add(insertedRootId);
                // Update data and re-render
                const newData = JSON.parse(jsonInput.value);
                newData.patterns = patternsArray;
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(newData), jsonNumberReplacer, 2);
                renderWorkoutTable(newData);
                // After render, persist diff entries for all actual cells in the new subtree and mark UI green
                setTimeout(() => {
                    const persistAndHighlight = (rowEl, node) => {
                        const nodeIdentifier = rowEl.id;
                        const tds = rowEl.querySelectorAll('td[data-property]');
                        const propsForHighlight = [];
                        tds.forEach(td => {
                            const propName = td.getAttribute('data-property');
                            if (!propName) return;
                            const cellKey = `${nodeIdentifier}-${propName}`;
                            updatedCells.set(cellKey, true);
                            const isNested = propName.includes('.');
                            const propertyKey = isNested
                                ? `${node?.type || 'Node'}-${(node?.name || nodeIdentifier)}-config.${propName}`
                                : `${node?.type || 'Node'}-${(node?.name || nodeIdentifier)}-${propName}`;
                            updatedProperties.set(propertyKey, true);
                            if (propName === 'intervalOffset.min') propsForHighlight.push('intervalOffsetMin');
                            else if (propName === 'intervalOffset.max') propsForHighlight.push('intervalOffsetMax');
                            else propsForHighlight.push(propName);
                        });
                        if (propsForHighlight.length > 0) {
                            highlightMatchingCells(rowEl, propsForHighlight, 'update-cell-highlight');
                        }
                    };

                    const insertedRow = document.getElementById(insertedRootId);
                    if (!insertedRow) return;

                    // BFS over the newly inserted pattern subtree
                    const queue = [insertedRootId];
                    const visitedIds = new Set();
                    while (queue.length > 0) {
                        const currentId = queue.shift();
                        if (visitedIds.has(currentId)) continue;
                        visitedIds.add(currentId);
                        const rowEl = document.getElementById(currentId);
                        if (rowEl) {
                            // Find node details from currentWorkoutData for property keys
                            const node = findNodeById(currentWorkoutData, currentId);
                            // Persist and highlight this row
                            updatedRows.add(currentId);
                            persistAndHighlight(rowEl, node);
                        }
                        // Enqueue direct children
                        const childRows = document.querySelectorAll(`tr[data-parent-id="${currentId}"]`);
                        childRows.forEach(cr => queue.push(cr.id));
                    }

                    // Update green counter after applying highlights
                    const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                    updateGreenNavIndex(-1, greenCellsNow.length);
                }, 0);
                setTimeout(() => { isProgrammaticUpdate = false; }, 100);
                exitPasteMode();
                return;
            }
            // Insert after target for Shot/Message
            const nodeToInsert2 = JSON.parse(JSON.stringify(copiedRowData));
            regenerateIdsForSubtree(nodeToInsert2);
            const insertedRootId2 = nodeToInsert2.id;
            childrenArray.splice(targetIndex + 1, 0, nodeToInsert2);
            // Mark inserted row as changed (green highlight)
            updatedRows.add(insertedRootId2);
            isProgrammaticUpdate = true;
            jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
            renderWorkoutTable(currentWorkoutData);
            // After render, persist diff entries for all actual cells in the new subtree and mark UI green
            setTimeout(() => {
                const persistAndHighlight = (rowEl, node) => {
                    const nodeIdentifier = rowEl.id;
                    const tds = rowEl.querySelectorAll('td[data-property]');
                    const propsForHighlight = [];
                    tds.forEach(td => {
                        const propName = td.getAttribute('data-property');
                        if (!propName) return;
                        const cellKey = `${nodeIdentifier}-${propName}`;
                        updatedCells.set(cellKey, true);
                        const isNested = propName.includes('.');
                        const propertyKey = isNested
                            ? `${node?.type || 'Node'}-${(node?.name || nodeIdentifier)}-config.${propName}`
                            : `${node?.type || 'Node'}-${(node?.name || nodeIdentifier)}-${propName}`;
                        updatedProperties.set(propertyKey, true);
                        if (propName === 'intervalOffset.min') propsForHighlight.push('intervalOffsetMin');
                        else if (propName === 'intervalOffset.max') propsForHighlight.push('intervalOffsetMax');
                        else propsForHighlight.push(propName);
                    });
                    if (propsForHighlight.length > 0) {
                        highlightMatchingCells(rowEl, propsForHighlight, 'update-cell-highlight');
                    }
                };

                const insertedRow = document.getElementById(insertedRootId2);
                if (!insertedRow) return;

                // BFS over the newly inserted subtree under the same parent line
                const queue = [insertedRootId2];
                const visitedIds = new Set();
                while (queue.length > 0) {
                    const currentId = queue.shift();
                    if (visitedIds.has(currentId)) continue;
                    visitedIds.add(currentId);
                    const rowEl = document.getElementById(currentId);
                    if (rowEl) {
                        const node = findNodeById(currentWorkoutData, currentId);
                        updatedRows.add(currentId);
                        persistAndHighlight(rowEl, node);
                    }
                    const childRows = document.querySelectorAll(`tr[data-parent-id="${currentId}"]`);
                    childRows.forEach(cr => queue.push(cr.id));
                }

                const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                updateGreenNavIndex(-1, greenCellsNow.length);
            }, 0);
            setTimeout(() => { isProgrammaticUpdate = false; }, 100);
            exitPasteMode();
        }

        function regenerateIdsForSubtree(node) {
            if (!node || typeof node !== 'object') return;
            if (node.type) {
                const timestamp = Date.now();
                const randomSuffix = Math.random().toString(36).substring(2, 8);
                node.id = `${node.type.toLowerCase()}_${timestamp}_${randomSuffix}`;
            }
            if (Array.isArray(node.patterns)) {
                node.patterns.forEach(child => regenerateIdsForSubtree(child));
            }
            if (Array.isArray(node.entries)) {
                node.entries.forEach(child => regenerateIdsForSubtree(child));
            }
        }
        function enterCutMode() {
            if (cutModeActive) return;
            if (addModeActive) exitAddMode();
            cutModeActive = true;
            cutSelectedRowId = null;
            // Visually indicate active state on the cut button
            if (cutModeButton) {
                cutModeButton.classList.remove('bg-orange-600');
                cutModeButton.classList.add('bg-orange-800', 'ring-2', 'ring-offset-2', 'ring-orange-300');
                cutModeButton.setAttribute('aria-pressed', 'true');
                cutModeButton.title = 'Cut (active): click a row to delete, or click again to cancel';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.add('cut-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handleCutRowClick, true);
            });
            showSuccessMessage('Cut mode: Click a row to delete (confirmation required)');
        }

        // --- Add Mode ---
        function enterAddMode() {
            if (addModeActive) return;
            // Turn off other modes
            if (cutModeActive) exitCutMode();
            if (copyModeActive) exitCopyMode();
            if (pasteModeActive) exitPasteMode();
            addModeActive = true;
            if (addModeButton) {
                addModeButton.classList.remove('bg-teal-600');
                addModeButton.classList.add('bg-teal-800', 'ring-2', 'ring-offset-2', 'ring-teal-300');
                addModeButton.setAttribute('aria-pressed', 'true');
                addModeButton.title = 'Add (active): click a row to insert a new entry after it, or click again to cancel';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.add('add-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handleAddRowClick, true);
                row.addEventListener('mouseenter', () => {
                    if (addModeActive) row.classList.add('add-row-hover');
                });
                row.addEventListener('mouseleave', () => {
                    row.classList.remove('add-row-hover');
                });
            });
            showSuccessMessage('Add mode: click a row to insert a new entry after it');
        }

        function exitAddMode() {
            addModeActive = false;
            if (addModeButton) {
                addModeButton.classList.add('bg-teal-600');
                addModeButton.classList.remove('bg-teal-800', 'ring-2', 'ring-offset-2', 'ring-teal-300');
                addModeButton.setAttribute('aria-pressed', 'false');
                addModeButton.title = 'Add: create a new entry after a row';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.remove('add-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.removeEventListener('click', handleAddRowClick, true);
                row.classList.remove('add-insert-highlight');
                row.classList.remove('add-row-hover');
            });
        }

        function createDefaultEntry(afterNode) {
            // Create a reasonable default new entry (Shot) following current conventions
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substring(2, 8);
            return {
                type: 'Shot',
                id: `shot_${timestamp}_${randomSuffix}`,
                name: 'New Shot',
                positionType: 'normal',
                config: {}
            };
        }

        function createDefaultPattern() {
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substring(2, 8);
            return {
                type: 'Pattern',
                id: `pattern_${timestamp}_${randomSuffix}`,
                name: 'New Pattern',
                positionType: 'normal',
                config: {},
                entries: []
            };
        }

        function handleAddRowClick(event) {
            if (!addModeActive) return;
            event.preventDefault();
            event.stopPropagation();
            const targetRow = event.currentTarget;
            document.querySelectorAll('tr.add-insert-highlight').forEach(el => el.classList.remove('add-insert-highlight'));
            targetRow.classList.add('add-insert-highlight');

            const targetNodeId = targetRow.id;
            const targetNode = findNodeById(currentWorkoutData, targetNodeId);
            if (!targetNode) { showError('Could not find target node for insertion'); return; }

            // If clicking the Workout row, insert a new Pattern under the workout
            if (targetNode.type === 'Workout') {
                if (!Array.isArray(targetNode.patterns)) targetNode.patterns = [];
                const nodeToInsert = createDefaultPattern();
                const insertedRootId = nodeToInsert.id;
                // Insert as first pattern under workout for immediate visibility
                targetNode.patterns.splice(0, 0, nodeToInsert);

                updatedRows.add(insertedRootId);
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    const insertedRow = document.getElementById(insertedRootId);
                    if (insertedRow) {
                        const tds = insertedRow.querySelectorAll('td[data-property]');
                        const propsForHighlight = [];
                        tds.forEach(td => {
                            const propName = td.getAttribute('data-property');
                            if (!propName) return;
                            const cellKey = `${insertedRootId}-${propName}`;
                            updatedCells.set(cellKey, true);
                            const isNested = propName.includes('.');
                            const propertyKey = isNested
                                ? `${nodeToInsert.type}-${(nodeToInsert.name || insertedRootId)}-config.${propName}`
                                : `${nodeToInsert.type}-${(nodeToInsert.name || insertedRootId)}-${propName}`;
                            updatedProperties.set(propertyKey, true);
                            if (propName === 'intervalOffset.min') propsForHighlight.push('intervalOffsetMin');
                            else if (propName === 'intervalOffset.max') propsForHighlight.push('intervalOffsetMax');
                            else propsForHighlight.push(propName);
                        });
                        updatedRows.add(insertedRootId);
                        if (propsForHighlight.length > 0) {
                            highlightMatchingCells(insertedRow, propsForHighlight, 'update-cell-highlight');
                        }
                        const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                        updateGreenNavIndex(-1, greenCellsNow.length);
                    }
                    isProgrammaticUpdate = false;
                }, 0);
                exitAddMode();
                return;
            }

            // Determine parent and children array
            let parentNode = findParentNode(currentWorkoutData, targetNode);
            let childrenArray = parentNode ? (parentNode.patterns || parentNode.entries) : null;

            // If clicking on a Pattern row with entries, insert as first child under it
            if (targetNode.type === 'Pattern') {
                parentNode = targetNode;
                if (!Array.isArray(parentNode.entries)) parentNode.entries = [];
                childrenArray = parentNode.entries;
                const nodeToInsert = createDefaultEntry(targetNode);
                const insertedRootId = nodeToInsert.id;
                childrenArray.splice(0, 0, nodeToInsert);

                updatedRows.add(insertedRootId);
                isProgrammaticUpdate = true;
                jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
                renderWorkoutTable(currentWorkoutData);
                setTimeout(() => {
                    const insertedRow = document.getElementById(insertedRootId);
                    if (insertedRow) {
                        // Persist all actual cells as changed and highlight green
                        const tds = insertedRow.querySelectorAll('td[data-property]');
                        const propsForHighlight = [];
                        tds.forEach(td => {
                            const propName = td.getAttribute('data-property');
                            if (!propName) return;
                            const cellKey = `${insertedRootId}-${propName}`;
                            updatedCells.set(cellKey, true);
                            const isNested = propName.includes('.');
                            const propertyKey = isNested
                                ? `${nodeToInsert.type}-${(nodeToInsert.name || insertedRootId)}-config.${propName}`
                                : `${nodeToInsert.type}-${(nodeToInsert.name || insertedRootId)}-${propName}`;
                            updatedProperties.set(propertyKey, true);
                            if (propName === 'intervalOffset.min') propsForHighlight.push('intervalOffsetMin');
                            else if (propName === 'intervalOffset.max') propsForHighlight.push('intervalOffsetMax');
                            else propsForHighlight.push(propName);
                        });
                        updatedRows.add(insertedRootId);
                        if (propsForHighlight.length > 0) {
                            highlightMatchingCells(insertedRow, propsForHighlight, 'update-cell-highlight');
                        }
                        const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                        updateGreenNavIndex(-1, greenCellsNow.length);
                    }
                    isProgrammaticUpdate = false;
                }, 0);
                exitAddMode();
                return;
            }

            // Otherwise insert after the clicked row within its parent's array
            if (!parentNode || !Array.isArray(childrenArray)) { showError('Parent node does not have a children array'); return; }
            const targetIndex = childrenArray.findIndex(child => child === targetNode);
            if (targetIndex === -1) { showError('Could not find target node in parent array'); return; }

            const nodeToInsert2 = createDefaultEntry(targetNode);
            const insertedRootId2 = nodeToInsert2.id;
            childrenArray.splice(targetIndex + 1, 0, nodeToInsert2);

            updatedRows.add(insertedRootId2);
            isProgrammaticUpdate = true;
            jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
            renderWorkoutTable(currentWorkoutData);
            setTimeout(() => {
                const insertedRow = document.getElementById(insertedRootId2);
                if (insertedRow) {
                    const tds = insertedRow.querySelectorAll('td[data-property]');
                    const propsForHighlight = [];
                    tds.forEach(td => {
                        const propName = td.getAttribute('data-property');
                        if (!propName) return;
                        const cellKey = `${insertedRootId2}-${propName}`;
                        updatedCells.set(cellKey, true);
                        const isNested = propName.includes('.');
                        const propertyKey = isNested
                            ? `${nodeToInsert2.type}-${(nodeToInsert2.name || insertedRootId2)}-config.${propName}`
                            : `${nodeToInsert2.type}-${(nodeToInsert2.name || insertedRootId2)}-${propName}`;
                        updatedProperties.set(propertyKey, true);
                        if (propName === 'intervalOffset.min') propsForHighlight.push('intervalOffsetMin');
                        else if (propName === 'intervalOffset.max') propsForHighlight.push('intervalOffsetMax');
                        else propsForHighlight.push(propName);
                    });
                    updatedRows.add(insertedRootId2);
                    if (propsForHighlight.length > 0) {
                        highlightMatchingCells(insertedRow, propsForHighlight, 'update-cell-highlight');
                    }
                    const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                    updateGreenNavIndex(-1, greenCellsNow.length);
                }
                isProgrammaticUpdate = false;
            }, 0);
            exitAddMode();
        }

        function exitCutMode() {
            cutModeActive = false;
            cutSelectedRowId = null;
            // Reset cut button visual state
            if (cutModeButton) {
                cutModeButton.classList.add('bg-orange-600');
                cutModeButton.classList.remove('bg-orange-800', 'ring-2', 'ring-offset-2', 'ring-orange-300');
                cutModeButton.setAttribute('aria-pressed', 'false');
                cutModeButton.title = 'Cut: select a row to delete';
            }
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.remove('cut-mode');
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.removeEventListener('click', handleCutRowClick, true);
                row.classList.remove('cut-row-highlight');
            });
        }

        function handleCutRowClick(event) {
            if (!cutModeActive) return;
            event.preventDefault();
            event.stopPropagation();
            const row = event.currentTarget;
            // Clear previous selection
            document.querySelectorAll('tr.cut-row-highlight').forEach(el => el.classList.remove('cut-row-highlight'));
            // Highlight selected row
            row.classList.add('cut-row-highlight');
            cutSelectedRowId = row.id;
            // Show confirm modal
            modalMessage.textContent = 'Are you sure you want to delete this row? This action cannot be undone.';
            confirmationModal.classList.remove('hidden');
        }

        function jsonNumberReplacer(key, value) {
            // Only format numbers for relevant keys
            if (typeof value === 'number') {
                if (
                    key === 'interval' ||
                    key === 'intervalOffsetMin' ||
                    key === 'intervalOffsetMax' ||
                    key === 'min' && this.intervalOffset !== undefined ||
                    key === 'max' && this.intervalOffset !== undefined ||
                    key === 'shotAnnouncementLeadTime'
                ) {
                    // Return number with 2 decimal places precision
                    return Number(value.toFixed(2));
                }
                if (key === 'speechRate') {
                    // Return number with 1 decimal place precision
                    return Number(value.toFixed(1));
                }
                if (key === 'repeatCount') {
                    return Math.round(value);
                }
            }
            return value;
        }

        // --- Saved Elements Functions ---
        
        // Load saved elements from localStorage on page load
        function loadSavedElements() {
            try {
                const saved = localStorage.getItem('squashWorkoutSavedElements');
                if (saved) {
                    savedElements = JSON.parse(saved);
                    renderSavedElements();
                }
            } catch (e) {
                console.error('Failed to load saved elements:', e);
                savedElements = [];
            }
        }
        
        // Save elements to localStorage
        function saveElementsToStorage() {
            try {
                localStorage.setItem('squashWorkoutSavedElements', JSON.stringify(savedElements));
            } catch (e) {
                console.error('Failed to save elements to storage:', e);
            }
        }
        
        // Render the saved elements list
        function renderSavedElements() {
            if (!savedElementsList) return;
            
            if (savedElements.length === 0) {
                savedElementsList.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        <svg class="w-6 h-6 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 5a2 0 012-2h10a2 2 0 012 2v16l-7-3.5L5 21V5z"></path>
                        </svg>
                        <p class="text-xs">No saved elements</p>
                    </div>
                `;
                return;
            }
            
            savedElementsList.innerHTML = '';
            savedElements.forEach((element, index) => {
                const elementDiv = document.createElement('div');
                elementDiv.className = 'bg-gray-50 border border-gray-200 rounded-lg p-3 cursor-pointer hover:bg-gray-100 transition-colors';
                elementDiv.title = `Click to paste this ${element.type} element`;
                
                elementDiv.innerHTML = `
                    <div class="flex items-start justify-between">
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${
                                    element.type === 'Workout' ? 'bg-red-100 text-red-800' :
                                    element.type === 'Pattern' ? 'bg-purple-100 text-purple-800' :
                                    element.type === 'Shot' ? 'bg-blue-100 text-blue-800' :
                                    'bg-green-100 text-green-800'
                                }">${element.type}</span>
                                <span class="text-sm font-medium text-gray-900 truncate">${element.name || 'Unnamed'}</span>
                            </div>
                            <div class="text-xs text-gray-600">
                                ${element.config?.interval ? `Interval: ${element.config.interval}s` : ''}
                                ${element.config?.repeatCount ? ` • Repeat: ${JSON.stringify(element.config.repeatCount)}` : ''}
                                ${element.config?.message ? ` • Message: ${element.config.message.substring(0, 30)}${element.config.message.length > 30 ? '...' : ''}` : ''}
                            </div>
                        </div>
                        <button class="text-red-500 hover:text-red-700 transition-colors" title="Remove saved element" onclick="confirmRemoveSavedElement(${index})">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75">
                                <path d="M10 5a2 2 0 0 0-1.344.519l-6.328 5.74a1 1 0 0 0 0 1.481l6.328 5.741A2 2 0 0 0 10 19h10a2 2 0 0 0 2-2V7a2 2 0 0 0-2-2zm2 4 6 6m0-6-6 6"/>
                            </svg>
                        </button>
                    </div>
                `;
                
                // Add click handler to paste the element when clicking on the div
                elementDiv.addEventListener('click', (e) => {
                    if (e.target.closest('button')) return; // Don't paste if clicking remove button
                    handlePasteSavedElement(element);
                });
                
                savedElementsList.appendChild(elementDiv);
            });
        }
        
        // Handle saving a selected element
        function handleSaveElement() {
            if (saveModeActive) {
                exitSaveMode();
                return;
            }
            
            enterSaveMode();
        }
        
        // Enter save mode
        function enterSaveMode() {
            if (saveModeActive) return;
            
            // Turn off other modes
            if (cutModeActive) exitCutMode();
            if (copyModeActive) exitCopyMode();
            if (pasteModeActive) exitPasteMode();
            if (addModeActive) exitAddMode();
            
            saveModeActive = true;
            selectedRowForSaving = null;
            
            // Button visual
            if (saveElementBtn) {
                saveElementBtn.classList.remove('bg-blue-600');
                saveElementBtn.classList.add('bg-blue-800', 'ring-2', 'ring-offset-2', 'ring-blue-300');
                saveElementBtn.setAttribute('aria-pressed', 'true');
                saveElementBtn.title = 'Save (active): click a row to save it, or click again to cancel';
            }
            
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.add('save-mode');
            
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handleSaveRowClick, true);
                // Live hover preview of selection box in save mode
                row.addEventListener('mouseenter', () => {
                    if (saveModeActive) row.classList.add('save-row-hover');
                });
                row.addEventListener('mouseleave', () => {
                    row.classList.remove('save-row-hover');
                });
            });
            
            showSuccessMessage('Save mode: Click a row to save it to Saved Elements');
        }
        
        // Exit save mode
        function exitSaveMode() {
            saveModeActive = false;
            if (saveElementBtn) {
                saveElementBtn.classList.add('bg-blue-600');
                saveElementBtn.classList.remove('bg-blue-800', 'ring-2', 'ring-offset-2', 'ring-blue-300');
                saveElementBtn.setAttribute('aria-pressed', 'false');
                saveElementBtn.title = 'Save: select a row in the table to add to Saved Elements';
            }
            
            const tableEl = workoutDisplay.querySelector('table');
            if (tableEl) tableEl.classList.remove('save-mode');
            
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.removeEventListener('click', handleSaveRowClick, true);
                row.classList.remove('save-row-highlight');
                row.classList.remove('save-row-hover');
            });
            
            // Clear selection
            selectedRowForSaving = null;
            document.querySelectorAll('tr').forEach(row => row.classList.remove('selected-for-saving'));
        }
        
        // Handle save row click
        function handleSaveRowClick(event) {
            if (!saveModeActive) return;
            event.preventDefault();
            event.stopPropagation();
            
            const row = event.currentTarget;
            
            // Clear previous selection
            document.querySelectorAll('tr.save-row-highlight').forEach(el => el.classList.remove('save-row-highlight'));
            
            // Highlight selected row
            row.classList.add('save-row-highlight');
            selectedRowForSaving = row.id;
            
            const node = findNodeById(currentWorkoutData, row.id);
            if (!node) {
                showError('Could not find the selected row data.');
                return;
            }
            
            // Check if element with same ID already exists
            const existingIndex = savedElements.findIndex(el => el.id === node.id);
            if (existingIndex !== -1) {
                // Ask for confirmation to replace
                if (confirm(`Element "${node.name || node.type}" already exists in Saved Elements. Replace it?`)) {
                    savedElements[existingIndex] = JSON.parse(JSON.stringify(node));
                    saveElementsToStorage();
                    renderSavedElements();
                    showSuccessMessage(`Updated saved ${node.type} element: ${node.name || node.type}`);
                }
            } else {
                // Add new element
                savedElements.push(JSON.parse(JSON.stringify(node)));
                saveElementsToStorage();
                renderSavedElements();
                showSuccessMessage(`Saved ${node.type} element: ${node.name || node.type}`);
            }
            
            exitSaveMode();
        }
        
        // Handle pasting a saved element
        function handlePasteSavedElement(element) {
            if (!currentWorkoutData) {
                showError('Please load a workout first.');
                return;
            }
            
            // Show a message to select where to paste
            showSuccessMessage(`Click on a row in the table to paste the ${element.type} element under it`);
            
            // Store the element to paste
            selectedSavedElement = element;
            
            // Enable paste mode highlighting
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handleDirectPaste, true);
                // Live hover preview
                row.addEventListener('mouseenter', () => {
                    row.classList.add('saved-paste-row-hover');
                });
                row.addEventListener('mouseleave', () => {
                    row.classList.remove('saved-paste-row-hover');
                });
            });
        }
        
        // Handle direct paste when clicking a row
        function handleDirectPaste(event) {
            if (!selectedSavedElement) return;
            
            event.preventDefault();
            event.stopPropagation();
            
            const targetRow = event.currentTarget;
            const targetNodeId = targetRow.id;
            const targetNode = findNodeById(currentWorkoutData, targetNodeId);
            
            if (!targetNode) {
                showError('Could not find target node for insertion.');
                return;
            }
            
            // Create a deep copy with new ID
            const elementToPaste = JSON.parse(JSON.stringify(selectedSavedElement));
            const timestamp = Date.now();
            const randomSuffix = Math.random().toString(36).substring(2, 8);
            
            // Generate new unique ID
            if (elementToPaste.type === 'Shot') {
                elementToPaste.id = `shot_${timestamp}_${randomSuffix}`;
            } else if (elementToPaste.type === 'Pattern') {
                elementToPaste.id = `pattern_${timestamp}_${randomSuffix}`;
                // Clear any existing entries to avoid conflicts
                elementToPaste.entries = [];
            } else if (elementToPaste.type === 'Message') {
                elementToPaste.id = `msg_${timestamp}_${randomSuffix}`;
            }
            
            // Determine parent and insertion point
            let parentNode = findParentNode(currentWorkoutData, targetNode);
            if (!parentNode) {
                showError('Could not find parent node for insertion.');
                return;
            }
            
            let childrenArray = parentNode.patterns || parentNode.entries;
            if (!Array.isArray(childrenArray)) {
                showError('Parent node does not have a children array.');
                return;
            }
            
            const targetIndex = childrenArray.findIndex(child => child === targetNode);
            if (targetIndex === -1) {
                showError('Could not find target node in parent array.');
                return;
            }
            
            // Insert after target
            childrenArray.splice(targetIndex + 1, 0, elementToPaste);
            
            // Mark inserted row as changed (green highlight)
            updatedRows.add(elementToPaste.id);
            
            // Update data and re-render
            isProgrammaticUpdate = true;
            jsonInput.value = JSON.stringify(filterNodeIds(currentWorkoutData), jsonNumberReplacer, 2);
            renderWorkoutTable(currentWorkoutData);
            
            // After render, mark the inserted row as changed
            setTimeout(() => {
                const insertedRow = document.getElementById(elementToPaste.id);
                if (insertedRow) {
                    updatedRows.add(elementToPaste.id);
                    const tds = insertedRow.querySelectorAll('td[data-property]');
                    tds.forEach(td => {
                        const propName = td.getAttribute('data-property');
                        if (!propName) return;
                        const cellKey = `${elementToPaste.id}-${propName}`;
                        updatedCells.set(cellKey, true);
                    });
                    
                    // Update green counter
                    const greenCellsNow = document.querySelectorAll('.update-cell-highlight');
                    updateGreenNavIndex(-1, greenCellsNow.length);
                }
                isProgrammaticUpdate = false;
            }, 0);
            
            showSuccessMessage(`Pasted ${elementToPaste.type} element: ${elementToPaste.name || elementToPaste.type}`);
            
            // Clean up
            selectedSavedElement = null;
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.removeEventListener('click', handleDirectPaste, true);
                row.classList.remove('saved-paste-row-hover');
            });
        }
        

        

        

        

        

        

        

        
        // Remove a saved element
        function removeSavedElement(index) {
            if (index >= 0 && index < savedElements.length) {
                const removed = savedElements.splice(index, 1)[0];
                showSuccessMessage(`Removed saved ${removed.type} element: ${removed.name || removed.type}`);
                saveElementsToStorage();
                renderSavedElements();
            }
        }
        
        // Confirm removal of a saved element
        function confirmRemoveSavedElement(index) {
            if (index >= 0 && index < savedElements.length) {
                const element = savedElements[index];
                const elementName = element.name || element.type;
                
                if (confirm(`Are you sure you want to remove "${elementName}" from your saved elements?`)) {
                    removeSavedElement(index);
                }
            }
        }
        

        
        // Add row selection for saving
        function enableRowSelectionForSaving() {
            const rows = workoutDisplay.querySelectorAll('tbody tr');
            rows.forEach(row => {
                row.addEventListener('click', handleRowClickForSaving);
            });
        }
        
        function handleRowClickForSaving(event) {
            // Only handle if not in other modes
            if (cutModeActive || copyModeActive || pasteModeActive || addModeActive || moveModeActive || saveModeActive) {
                return;
            }
            
            // Clear previous selection
            document.querySelectorAll('tr').forEach(r => r.classList.remove('selected-for-saving'));
            
            // Select current row
            const row = event.currentTarget;
            row.classList.add('selected-for-saving');
            selectedRowForSaving = row.id;
            
            // Highlight the save button
            if (saveElementBtn) {
                saveElementBtn.classList.add('ring-2', 'ring-blue-300', 'ring-offset-2');
            }
        }
        
        // Initialize saved elements on page load
        document.addEventListener('DOMContentLoaded', () => {
            loadSavedElements();
        });
        
        // Make functions globally accessible for onclick handlers
        window.removeSavedElement = removeSavedElement;
        window.confirmRemoveSavedElement = confirmRemoveSavedElement;
        
        // --- Preview Functions ---
        
        function generateLivePreview() {
            if (!currentWorkoutData) {
                previewSummary.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        <svg class="w-8 h-8 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <p class="text-sm">No workout loaded</p>
                    </div>
                `;
                previewTimeline.innerHTML = `
                    <div class="text-center text-gray-500 py-4">
                        <svg class="w-8 h-8 mx-auto mb-2 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                        </svg>
                        <p class="text-sm">Timeline will appear here</p>
                    </div>
                `;
                return;
            }

            const previewResult = window.WorkoutLib.generatePreviewHtml(currentWorkoutData);
            if (previewResult && previewResult.html) {
                // Extract summary section (everything before the first superset)
                const summaryMatch = previewResult.html.match(/<div class="mb-6 p-4 bg-white rounded-lg shadow-sm border border-gray-200">([\s\S]*?)<\/div>\s*<\/div>\s*<\/div>/);
                if (summaryMatch) {
                    let summaryHtml = summaryMatch[1];

                    // Remove inner Summary heading block and the initial HR under it
                    summaryHtml = summaryHtml.replace(/<div class=\"flex items-center justify-between mb-2\">[\s\S]*?<\/div>\s*/,'');
                    summaryHtml = summaryHtml.replace(/<hr class=\"border-gray-200 mb-4\">\s*/,'');

                    // Add horizontal ruler after the summary blurb
                    summaryHtml = summaryHtml + '<hr class="my-6 border-gray-300">';

                    previewSummary.innerHTML = summaryHtml;
                }

                // Extract timeline section (everything after the summary) and filter out sub-shot timings
                const timelineMatch = previewResult.html.match(/<div class="mb-6 p-4 bg-white rounded-lg shadow-sm border border-gray-200">[\s\S]*?<\/div>\s*<\/div>\s*<\/div>([\s\S]*)/);
                if (timelineMatch) {
                    let timelineHtml = timelineMatch[1];

                    // Remove sub-shot timing details (announcements, split step, countdown, etc.)
                    // Strip any container row that includes a rocket-timing-badge (sub-event rows)
                    timelineHtml = timelineHtml.replace(/<div[^>]*>\s*<span[^>]*class=\"[^\"]*rocket-timing-badge[^\"]*\"[\s\S]*?<\/div>/g, '');

                    // Clean up any empty lines or excessive spacing
                    timelineHtml = timelineHtml.replace(/\n\s*\n\s*\n/g, '\n\n');

                    previewTimeline.innerHTML = timelineHtml;
                }
            }
        }
        
        
    </script>
</body>
</html>
